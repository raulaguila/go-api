
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>generator: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/raulaguila/go-api/cmd/generator/generator.go (0.0%)</option>
				
				<option value="file1">github.com/raulaguila/go-api/cmd/go-api/go-api.go (0.0%)</option>
				
				<option value="file2">github.com/raulaguila/go-api/configs/configs.go (100.0%)</option>
				
				<option value="file3">github.com/raulaguila/go-api/docs/docs.go (0.0%)</option>
				
				<option value="file4">github.com/raulaguila/go-api/internal/api/rest/handler/authHandler.go (0.0%)</option>
				
				<option value="file5">github.com/raulaguila/go-api/internal/api/rest/handler/auxFilter.go (0.0%)</option>
				
				<option value="file6">github.com/raulaguila/go-api/internal/api/rest/handler/errorHandler.go (0.0%)</option>
				
				<option value="file7">github.com/raulaguila/go-api/internal/api/rest/handler/miscHandler.go (0.0%)</option>
				
				<option value="file8">github.com/raulaguila/go-api/internal/api/rest/handler/productHandler.go (0.0%)</option>
				
				<option value="file9">github.com/raulaguila/go-api/internal/api/rest/handler/profileHandler.go (0.0%)</option>
				
				<option value="file10">github.com/raulaguila/go-api/internal/api/rest/handler/userHandler.go (0.0%)</option>
				
				<option value="file11">github.com/raulaguila/go-api/internal/api/rest/middleware/authMiddleware.go (0.0%)</option>
				
				<option value="file12">github.com/raulaguila/go-api/internal/api/rest/middleware/datatransferobject/config.go (75.0%)</option>
				
				<option value="file13">github.com/raulaguila/go-api/internal/api/rest/middleware/datatransferobject/datatransferobject.go (83.3%)</option>
				
				<option value="file14">github.com/raulaguila/go-api/internal/api/rest/middleware/fileMiddleware.go (0.0%)</option>
				
				<option value="file15">github.com/raulaguila/go-api/internal/api/rest/rest.go (0.0%)</option>
				
				<option value="file16">github.com/raulaguila/go-api/internal/database/pgsql/pgsql.go (0.0%)</option>
				
				<option value="file17">github.com/raulaguila/go-api/internal/pkg/HTTPResponse/HTTPResponse.go (0.0%)</option>
				
				<option value="file18">github.com/raulaguila/go-api/internal/pkg/domain/authDomain.go (100.0%)</option>
				
				<option value="file19">github.com/raulaguila/go-api/internal/pkg/domain/productDomain.go (0.0%)</option>
				
				<option value="file20">github.com/raulaguila/go-api/internal/pkg/domain/profileDomain.go (100.0%)</option>
				
				<option value="file21">github.com/raulaguila/go-api/internal/pkg/domain/userDomain.go (40.0%)</option>
				
				<option value="file22">github.com/raulaguila/go-api/internal/pkg/mocks/authServiceMock.go (0.0%)</option>
				
				<option value="file23">github.com/raulaguila/go-api/internal/pkg/mocks/productRepositoryMock.go (0.0%)</option>
				
				<option value="file24">github.com/raulaguila/go-api/internal/pkg/mocks/productServiceMock.go (0.0%)</option>
				
				<option value="file25">github.com/raulaguila/go-api/internal/pkg/mocks/profileRepositoryMock.go (0.0%)</option>
				
				<option value="file26">github.com/raulaguila/go-api/internal/pkg/mocks/profileServiceMock.go (0.0%)</option>
				
				<option value="file27">github.com/raulaguila/go-api/internal/pkg/mocks/userRepositoryMock.go (0.0%)</option>
				
				<option value="file28">github.com/raulaguila/go-api/internal/pkg/mocks/userServiceMock.go (0.0%)</option>
				
				<option value="file29">github.com/raulaguila/go-api/internal/pkg/repository/productRepository.go (0.0%)</option>
				
				<option value="file30">github.com/raulaguila/go-api/internal/pkg/repository/profileRepository.go (0.0%)</option>
				
				<option value="file31">github.com/raulaguila/go-api/internal/pkg/repository/userRepository.go (0.0%)</option>
				
				<option value="file32">github.com/raulaguila/go-api/internal/pkg/service/authService.go (0.0%)</option>
				
				<option value="file33">github.com/raulaguila/go-api/internal/pkg/service/productService.go (0.0%)</option>
				
				<option value="file34">github.com/raulaguila/go-api/internal/pkg/service/profileService.go (0.0%)</option>
				
				<option value="file35">github.com/raulaguila/go-api/internal/pkg/service/userService.go (0.0%)</option>
				
				<option value="file36">github.com/raulaguila/go-api/mfa.go (0.0%)</option>
				
				<option value="file37">github.com/raulaguila/go-api/pkg/pgerror/pgerror.go (90.0%)</option>
				
				<option value="file38">github.com/raulaguila/go-api/pkg/pgfilter/pgfilter.go (100.0%)</option>
				
				<option value="file39">github.com/raulaguila/go-api/pkg/utils/duration.go (100.0%)</option>
				
				<option value="file40">github.com/raulaguila/go-api/pkg/utils/utils.go (100.0%)</option>
				
				<option value="file41">github.com/raulaguila/go-api/pkg/validator/error.go (100.0%)</option>
				
				<option value="file42">github.com/raulaguila/go-api/pkg/validator/validator.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bufio"
        "crypto/rand"
        "crypto/rsa"
        "crypto/x509"
        "encoding/base64"
        "encoding/pem"
        "fmt"
        "os"
        "strconv"

        "github.com/nexidian/gocliselect"
        "golang.org/x/crypto/bcrypt"

        "github.com/raulaguila/go-api/pkg/utils"
)

func generateRSAPrivateToken() <span class="cov0" title="0">{
        menu := gocliselect.NewMenu("Bit size of the key")

        menu.AddItem("1024 bits", "1024")
        menu.AddItem("2048 bits", "2048")
        menu.AddItem("3072 bits", "3072")
        menu.AddItem("4096 bits", "4096")

        bits, err := strconv.Atoi(menu.Display())
        utils.PanicIfErr(err)

        privateKey, err := rsa.GenerateKey(rand.Reader, bits)
        utils.PanicIfErr(err)

        fmt.Printf("Private key: %v\n\n", base64.StdEncoding.EncodeToString(pem.EncodeToMemory(&amp;pem.Block{
                Type:  "RSA PRIVATE KEY",
                Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
        })))
}</span>

func hashPassword() <span class="cov0" title="0">{
        fmt.Print("Enter user password: ")
        scanner := bufio.NewScanner(os.Stdin)
        scanner.Scan()

        hash, err := bcrypt.GenerateFromPassword([]byte(scanner.Text()), bcrypt.DefaultCost)
        utils.PanicIfErr(err)

        fmt.Printf("Hash: %s\n\n", hash)
}</span>

func printMenu() string <span class="cov0" title="0">{
        menu := gocliselect.NewMenu("Chose an option")

        menu.AddItem("Generate RSA Token", "rsa")
        menu.AddItem("Hash user password", "hash")
        menu.AddItem("Exit", "exit")

        return menu.Display()
}</span>

func main() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                switch choice := printMenu(); choice </span>{
                case "exit":<span class="cov0" title="0">
                        return</span>
                case "rsa":<span class="cov0" title="0">
                        generateRSAPrivateToken()</span>
                case "hash":<span class="cov0" title="0">
                        hashPassword()</span>
                }
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        _ "github.com/raulaguila/go-api/configs"
        "github.com/raulaguila/go-api/internal/api/rest"
        "github.com/raulaguila/go-api/internal/database/pgsql"
)

// @title                                                         Go API
// @description                                         This API is a user-friendly solution designed to serve as the foundation for more complex APIs.

// @contact.name                                        Raul del Aguila
// @contact.email                                        email@email.com

// @BasePath                                                /

// @securityDefinitions.apiKey                Bearer
// @in                                                                header
// @name                                                        Authorization
// @description                                         Type "Bearer" followed by a space and the JWT token.
func main() <span class="cov0" title="0">{
        rest.New(pgsql.ConnectPostgresDB())
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">package configs

import (
        "crypto/rsa"
        "embed"
        "encoding/base64"
        "os"
        "path"
        "runtime"
        "strings"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/joho/godotenv"

        "github.com/raulaguila/go-api/pkg/utils"
)

var (
        //go:embed locales/*
        Locales embed.FS

        //go:embed version.txt
        version string

        AccessPrivateKey  *rsa.PrivateKey
        RefreshPrivateKey *rsa.PrivateKey
)

func init() <span class="cov8" title="1">{
        err := godotenv.Load(path.Join("configs", ".env"))
        if err != nil </span><span class="cov8" title="1">{
                _, b, _, _ := runtime.Caller(0)
                utils.PanicIfErr(godotenv.Load(path.Join(path.Dir(b), ".env")))
        }</span>

        <span class="cov8" title="1">utils.PanicIfErr(os.Setenv("SYS_VERSION", strings.TrimSpace(version)))

        time.Local, err = time.LoadLocation(os.Getenv("TZ"))
        utils.PanicIfErr(err)

        </span><span class="cov8" title="1">{
                accessDecodedKey, err := base64.StdEncoding.DecodeString(os.Getenv("ACCESS_TOKEN_PRIVAT"))
                utils.PanicIfErr(err)

                AccessPrivateKey, err = jwt.ParseRSAPrivateKeyFromPEM(accessDecodedKey)
                utils.PanicIfErr(err)
        }</span>

        <span class="cov8" title="1">{
                refreshDecodedKey, err := base64.StdEncoding.DecodeString(os.Getenv("RFRESH_TOKEN_PRIVAT"))
                utils.PanicIfErr(err)

                RefreshPrivateKey, err = jwt.ParseRSAPrivateKeyFromPEM(refreshDecodedKey)
                utils.PanicIfErr(err)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {
            "name": "Raul del Aguila",
            "email": "email@email.com"
        },
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {
        "/": {
            "get": {
                "description": "Ping Pong",
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Ping"
                ],
                "summary": "Ping Pong",
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "additionalProperties": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "/auth": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "User authenticated",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "User authenticated",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User token",
                        "name": "Authorization",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.UserOutputDTO"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            },
            "put": {
                "description": "User refresh",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "User refresh",
                "parameters": [
                    {
                        "type": "string",
                        "description": "User token",
                        "name": "Authorization",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.AuthOutputDTO"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            },
            "post": {
                "description": "User authentication",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Auth"
                ],
                "summary": "User authentication",
                "parameters": [
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "description": "Credentials model",
                        "name": "credentials",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.AuthInputDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.AuthOutputDTO"
                        }
                    },
                    "401": {
                        "description": "Unauthorized",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            }
        },
        "/product": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "List products",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Product"
                ],
                "summary": "List products",
                "parameters": [
                    {
                        "enum": [
                            true,
                            false
                        ],
                        "type": "boolean",
                        "default": true,
                        "description": "Skip auth",
                        "name": "X-Skip-Auth",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "minimum": 1,
                        "type": "integer",
                        "default": 10,
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "asc",
                            "desc"
                        ],
                        "type": "string",
                        "default": "desc",
                        "name": "order",
                        "in": "query"
                    },
                    {
                        "minimum": 1,
                        "type": "integer",
                        "default": 1,
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "example": "name",
                        "name": "search",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "default": "updated_at",
                        "example": "updated_at",
                        "name": "sort",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dto.ItemsOutputDTO-dto_ProductOutputDTO"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Insert product",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Product"
                ],
                "summary": "Insert product",
                "parameters": [
                    {
                        "enum": [
                            true,
                            false
                        ],
                        "type": "boolean",
                        "default": true,
                        "description": "Skip auth",
                        "name": "X-Skip-Auth",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "description": "Product model",
                        "name": "product",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ProductInputDTO"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/dto.ProductOutputDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Delete products by IDs",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Product"
                ],
                "summary": "Delete products by IDs",
                "parameters": [
                    {
                        "enum": [
                            true,
                            false
                        ],
                        "type": "boolean",
                        "default": true,
                        "description": "Skip auth",
                        "name": "X-Skip-Auth",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "description": "Products ID",
                        "name": "ids",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.IDsInputDTO"
                        }
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            }
        },
        "/product/{id}": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Get product by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Product"
                ],
                "summary": "Get product by ID",
                "parameters": [
                    {
                        "enum": [
                            true,
                            false
                        ],
                        "type": "boolean",
                        "default": true,
                        "description": "Skip auth",
                        "name": "X-Skip-Auth",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "minimum": 1,
                        "type": "integer",
                        "example": 1,
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ProductOutputDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Update product by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Product"
                ],
                "summary": "Update product by ID",
                "parameters": [
                    {
                        "enum": [
                            true,
                            false
                        ],
                        "type": "boolean",
                        "default": true,
                        "description": "Skip auth",
                        "name": "X-Skip-Auth",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "minimum": 1,
                        "type": "integer",
                        "example": 1,
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Product model",
                        "name": "product",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ProductInputDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ProductOutputDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            }
        },
        "/profile": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Get profiles",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Profile"
                ],
                "summary": "Get profiles",
                "parameters": [
                    {
                        "enum": [
                            true,
                            false
                        ],
                        "type": "boolean",
                        "default": true,
                        "description": "Skip auth",
                        "name": "X-Skip-Auth",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "minimum": 1,
                        "type": "integer",
                        "default": 10,
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "asc",
                            "desc"
                        ],
                        "type": "string",
                        "default": "desc",
                        "name": "order",
                        "in": "query"
                    },
                    {
                        "minimum": 1,
                        "type": "integer",
                        "default": 1,
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "example": "name",
                        "name": "search",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "default": "updated_at",
                        "example": "updated_at",
                        "name": "sort",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dto.ItemsOutputDTO-dto_ProfileOutputDTO"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Insert profile",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Profile"
                ],
                "summary": "Insert profile",
                "parameters": [
                    {
                        "enum": [
                            true,
                            false
                        ],
                        "type": "boolean",
                        "default": true,
                        "description": "Skip auth",
                        "name": "X-Skip-Auth",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "description": "Profile model",
                        "name": "profile",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ProfileInputDTO"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/dto.ProfileOutputDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Delete profiles by IDs",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Profile"
                ],
                "summary": "Delete profiles by IDs",
                "parameters": [
                    {
                        "enum": [
                            true,
                            false
                        ],
                        "type": "boolean",
                        "default": true,
                        "description": "Skip auth",
                        "name": "X-Skip-Auth",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "description": "Profiles ID",
                        "name": "ids",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.IDsInputDTO"
                        }
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            }
        },
        "/profile/{id}": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Get profile by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Profile"
                ],
                "summary": "Get profile by ID",
                "parameters": [
                    {
                        "enum": [
                            true,
                            false
                        ],
                        "type": "boolean",
                        "default": true,
                        "description": "Skip auth",
                        "name": "X-Skip-Auth",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "minimum": 1,
                        "type": "integer",
                        "example": 1,
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ProfileOutputDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Update profile by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "Profile"
                ],
                "summary": "Update profile",
                "parameters": [
                    {
                        "enum": [
                            true,
                            false
                        ],
                        "type": "boolean",
                        "default": true,
                        "description": "Skip auth",
                        "name": "X-Skip-Auth",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "minimum": 1,
                        "type": "integer",
                        "example": 1,
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "Profile model",
                        "name": "profile",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.ProfileInputDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.ProfileOutputDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            }
        },
        "/user": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Get all users",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Get users",
                "parameters": [
                    {
                        "enum": [
                            true,
                            false
                        ],
                        "type": "boolean",
                        "default": true,
                        "description": "Skip auth",
                        "name": "X-Skip-Auth",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "minimum": 1,
                        "type": "integer",
                        "default": 10,
                        "name": "limit",
                        "in": "query"
                    },
                    {
                        "enum": [
                            "asc",
                            "desc"
                        ],
                        "type": "string",
                        "default": "desc",
                        "name": "order",
                        "in": "query"
                    },
                    {
                        "minimum": 1,
                        "type": "integer",
                        "default": 1,
                        "name": "page",
                        "in": "query"
                    },
                    {
                        "type": "integer",
                        "example": 1,
                        "name": "profile_id",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "example": "name",
                        "name": "search",
                        "in": "query"
                    },
                    {
                        "type": "string",
                        "default": "updated_at",
                        "example": "updated_at",
                        "name": "sort",
                        "in": "query"
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/dto.ItemsOutputDTO-dto_UserOutputDTO"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            },
            "post": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Insert user",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Insert user",
                "parameters": [
                    {
                        "enum": [
                            true,
                            false
                        ],
                        "type": "boolean",
                        "default": true,
                        "description": "Skip auth",
                        "name": "X-Skip-Auth",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "description": "User model",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.UserInputDTO"
                        }
                    }
                ],
                "responses": {
                    "201": {
                        "description": "Created",
                        "schema": {
                            "$ref": "#/definitions/dto.UserOutputDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "409": {
                        "description": "Conflict",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Delete user by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Delete user",
                "parameters": [
                    {
                        "enum": [
                            true,
                            false
                        ],
                        "type": "boolean",
                        "default": true,
                        "description": "Skip auth",
                        "name": "X-Skip-Auth",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "description": "User ID",
                        "name": "id",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.IDsInputDTO"
                        }
                    }
                ],
                "responses": {
                    "204": {
                        "description": "No Content"
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            }
        },
        "/user/pass": {
            "put": {
                "description": "Set user password by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Set user password",
                "parameters": [
                    {
                        "enum": [
                            true,
                            false
                        ],
                        "type": "boolean",
                        "default": true,
                        "description": "Skip auth",
                        "name": "X-Skip-Auth",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "type": "string",
                        "format": "email",
                        "description": "User email",
                        "name": "email",
                        "in": "query",
                        "required": true
                    },
                    {
                        "description": "Password model",
                        "name": "password",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.PasswordInputDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            },
            "delete": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Reset user password by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Reset user password",
                "parameters": [
                    {
                        "enum": [
                            true,
                            false
                        ],
                        "type": "boolean",
                        "default": true,
                        "description": "Skip auth",
                        "name": "X-Skip-Auth",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "type": "string",
                        "description": "User email",
                        "name": "email",
                        "in": "query",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK"
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            }
        },
        "/user/{id}": {
            "get": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Get user by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Get user",
                "parameters": [
                    {
                        "enum": [
                            true,
                            false
                        ],
                        "type": "boolean",
                        "default": true,
                        "description": "Skip auth",
                        "name": "X-Skip-Auth",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "minimum": 1,
                        "type": "integer",
                        "example": 1,
                        "name": "id",
                        "in": "path",
                        "required": true
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.UserOutputDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            },
            "put": {
                "security": [
                    {
                        "Bearer": []
                    }
                ],
                "description": "Update user by ID",
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "tags": [
                    "User"
                ],
                "summary": "Update user",
                "parameters": [
                    {
                        "enum": [
                            true,
                            false
                        ],
                        "type": "boolean",
                        "default": true,
                        "description": "Skip auth",
                        "name": "X-Skip-Auth",
                        "in": "header"
                    },
                    {
                        "enum": [
                            "en-US",
                            "pt-BR"
                        ],
                        "type": "string",
                        "default": "en-US",
                        "description": "Request language",
                        "name": "Accept-Language",
                        "in": "header"
                    },
                    {
                        "minimum": 1,
                        "type": "integer",
                        "example": 1,
                        "name": "id",
                        "in": "path",
                        "required": true
                    },
                    {
                        "description": "User model",
                        "name": "user",
                        "in": "body",
                        "required": true,
                        "schema": {
                            "$ref": "#/definitions/dto.UserInputDTO"
                        }
                    }
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "$ref": "#/definitions/dto.UserOutputDTO"
                        }
                    },
                    "400": {
                        "description": "Bad Request",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "404": {
                        "description": "Not Found",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error",
                        "schema": {
                            "$ref": "#/definitions/HTTPResponse.Response"
                        }
                    }
                }
            }
        }
    },
    "definitions": {
        "HTTPResponse.Response": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer",
                    "example": 400
                },
                "message": {
                    "type": "string",
                    "example": "status bad request"
                },
                "object": {}
            }
        },
        "dto.AuthInputDTO": {
            "type": "object",
            "properties": {
                "login": {
                    "type": "string",
                    "example": "admin@admin.com"
                },
                "password": {
                    "type": "string",
                    "example": "12345678"
                }
            }
        },
        "dto.AuthOutputDTO": {
            "type": "object",
            "properties": {
                "accesstoken": {
                    "type": "string"
                },
                "refreshtoken": {
                    "type": "string"
                },
                "user": {
                    "$ref": "#/definitions/dto.UserOutputDTO"
                }
            }
        },
        "dto.IDsInputDTO": {
            "type": "object",
            "properties": {
                "ids": {
                    "type": "array",
                    "items": {
                        "type": "integer"
                    }
                }
            }
        },
        "dto.ItemsOutputDTO-dto_ProductOutputDTO": {
            "type": "object",
            "properties": {
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/dto.ProductOutputDTO"
                    }
                },
                "pagination": {
                    "$ref": "#/definitions/dto.PaginationDTO"
                }
            }
        },
        "dto.ItemsOutputDTO-dto_ProfileOutputDTO": {
            "type": "object",
            "properties": {
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/dto.ProfileOutputDTO"
                    }
                },
                "pagination": {
                    "$ref": "#/definitions/dto.PaginationDTO"
                }
            }
        },
        "dto.ItemsOutputDTO-dto_UserOutputDTO": {
            "type": "object",
            "properties": {
                "items": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/dto.UserOutputDTO"
                    }
                },
                "pagination": {
                    "$ref": "#/definitions/dto.PaginationDTO"
                }
            }
        },
        "dto.PaginationDTO": {
            "type": "object",
            "properties": {
                "current_page": {
                    "type": "integer"
                },
                "page_size": {
                    "type": "integer"
                },
                "total_items": {
                    "type": "integer"
                },
                "total_pages": {
                    "type": "integer"
                }
            }
        },
        "dto.PasswordInputDTO": {
            "type": "object",
            "properties": {
                "password": {
                    "type": "string",
                    "example": "secret"
                },
                "password_confirm": {
                    "type": "string",
                    "example": "secret"
                }
            }
        },
        "dto.ProductInputDTO": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "example": "Product 01"
                }
            }
        },
        "dto.ProductOutputDTO": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer",
                    "example": 1
                },
                "name": {
                    "type": "string",
                    "example": "Product 01"
                }
            }
        },
        "dto.ProfileInputDTO": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "example": "ADMIN"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "dto.ProfileOutputDTO": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "integer",
                    "example": 1
                },
                "name": {
                    "type": "string",
                    "example": "ADMIN"
                },
                "permissions": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "dto.UserInputDTO": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string",
                    "example": "john.cena@email.com"
                },
                "name": {
                    "type": "string",
                    "example": "John Cena"
                },
                "profile_id": {
                    "type": "integer",
                    "example": 1
                },
                "status": {
                    "type": "boolean",
                    "example": true
                }
            }
        },
        "dto.UserOutputDTO": {
            "type": "object",
            "properties": {
                "email": {
                    "type": "string",
                    "example": "john.cena@email.com"
                },
                "id": {
                    "type": "integer",
                    "example": 1
                },
                "name": {
                    "type": "string",
                    "example": "John Cena"
                },
                "profile": {
                    "$ref": "#/definitions/dto.ProfileOutputDTO"
                },
                "status": {
                    "type": "boolean",
                    "example": true
                }
            }
        }
    },
    "securityDefinitions": {
        "Bearer": {
            "description": "Type \"Bearer\" followed by a space and the JWT token.",
            "type": "apiKey",
            "name": "Authorization",
            "in": "header"
        }
    }
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "",
        Host:             "",
        BasePath:         "/",
        Schemes:          []string{},
        Title:            "Go API",
        Description:      "This API is a user-friendly solution designed to serve as the foundation for more complex APIs.",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package handler

import (
        "github.com/gofiber/contrib/fiberi18n/v2"
        "github.com/gofiber/fiber/v2"
        "gorm.io/gorm"

        "github.com/raulaguila/go-api/internal/api/rest/middleware"
        "github.com/raulaguila/go-api/internal/pkg/HTTPResponse"
        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/internal/pkg/dto"
        "github.com/raulaguila/go-api/pkg/utils"
)

type AuthHandler struct {
        authService  domain.AuthService
        handlerError func(*fiber.Ctx, error) error
}

func NewAuthHandler(route fiber.Router, as domain.AuthService) <span class="cov0" title="0">{
        handler := &amp;AuthHandler{
                authService: as,
                handlerError: newErrorHandler(map[string]map[error][]any{
                        "*": {
                                utils.ErrDisabledUser:       []any{fiber.StatusUnauthorized, "disabledUser"},
                                utils.ErrInvalidCredentials: []any{fiber.StatusUnauthorized, "incorrectCredentials"},
                                gorm.ErrRecordNotFound:      []any{fiber.StatusNotFound, "userNotFound"},
                        },
                }),
        }

        route.Post("", handler.login)
        route.Get("", middleware.MidAccess, handler.me)
        route.Put("", middleware.MidRefresh, handler.refresh)
}</span>

// login godoc
// @Summary      User authentication
// @Description  User authentication
// @Tags         Auth
// @Accept       json
// @Produce      json
// @Param        Accept-Language        header        string                                false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        credentials                body        dto.AuthInputDTO        true        "Credentials model"
// @Success      200  {object}          dto.AuthOutputDTO
// @Failure      401  {object}          HTTPResponse.Response
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /auth [post]
func (s *AuthHandler) login(c *fiber.Ctx) error <span class="cov0" title="0">{
        credentials := new(dto.AuthInputDTO)
        if err := c.BodyParser(credentials); err != nil </span><span class="cov0" title="0">{
                return HTTPResponse.New(c, fiber.StatusBadRequest, fiberi18n.MustLocalize(c, "invalidData"), nil)
        }</span>

        <span class="cov0" title="0">authResponse, err := s.authService.Login(c.Context(), credentials)
        if err != nil </span><span class="cov0" title="0">{
                return s.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(authResponse)</span>
}

// me godoc
// @Summary      User authenticated
// @Description  User authenticated
// @Tags         Auth
// @Accept       json
// @Produce      json
// @Param        Authorization                header        string                                false        "User token"
// @Param        Accept-Language        header        string                                false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Success      200  {object}          dto.UserOutputDTO
// @Failure      401  {object}          HTTPResponse.Response
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /auth [get]
// @Security         Bearer
func (s *AuthHandler) me(c *fiber.Ctx) error <span class="cov0" title="0">{
        return c.Status(fiber.StatusOK).JSON(s.authService.Me(c.Locals(utils.LocalUser).(*domain.User)))
}</span>

// refresh godoc
// @Summary      User refresh
// @Description  User refresh
// @Tags         Auth
// @Accept       json
// @Produce      json
// @Param        Authorization                header        string                                false        "User token"
// @Param        Accept-Language        header        string                                false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Success      200  {object}          dto.AuthOutputDTO
// @Failure      401  {object}          HTTPResponse.Response
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /auth [put]
func (s *AuthHandler) refresh(c *fiber.Ctx) error <span class="cov0" title="0">{
        return c.Status(fiber.StatusOK).JSON(s.authService.Refresh(c.Locals(utils.LocalUser).(*domain.User)))
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package handler

import (
        "github.com/gofiber/fiber/v2"

        "github.com/raulaguila/go-api/internal/api/rest/middleware/datatransferobject"
        "github.com/raulaguila/go-api/internal/pkg/HTTPResponse"
        "github.com/raulaguila/go-api/internal/pkg/dto"
        "github.com/raulaguila/go-api/pkg/pgfilter"
        "github.com/raulaguila/go-api/pkg/utils"
)

var middlewareFilterDTO = datatransferobject.New(datatransferobject.Config{
        ContextKey: utils.LocalFilter,
        OnLookup:   datatransferobject.Query,
        Model:      &amp;pgfilter.Filter{},
})

var middlewareUserFilterDTO = datatransferobject.New(datatransferobject.Config{
        ContextKey: utils.LocalFilter,
        OnLookup:   datatransferobject.Query,
        Model:      &amp;dto.UserFilter{},
})

var middlewareIDDTO = datatransferobject.New(datatransferobject.Config{
        ContextKey: utils.LocalID,
        OnLookup:   datatransferobject.Params,
        Model:      &amp;dto.IDFilter{},
        ErrorHandler: func(c *fiber.Ctx, err error) error <span class="cov0" title="0">{
                return HTTPResponse.New(c, fiber.StatusBadRequest, "invalidID", nil)
        }</span>,
})

var middlewareIDsDTO = datatransferobject.New(datatransferobject.Config{
        ContextKey: utils.LocalID,
        OnLookup:   datatransferobject.Body,
        Model:      &amp;dto.IDsInputDTO{},
        ErrorHandler: func(c *fiber.Ctx, err error) error <span class="cov0" title="0">{
                return HTTPResponse.New(c, fiber.StatusBadRequest, "invalidID", nil)
        }</span>,
})
</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "errors"
        "log"
        "reflect"

        "github.com/gofiber/contrib/fiberi18n/v2"
        "github.com/gofiber/fiber/v2"

        "github.com/raulaguila/go-api/internal/pkg/HTTPResponse"
        "github.com/raulaguila/go-api/pkg/pgerror"
)

func newErrorHandler(possiblesErrors map[string]map[error][]any) func(*fiber.Ctx, error) error <span class="cov0" title="0">{
        return func(c *fiber.Ctx, err error) error </span><span class="cov0" title="0">{
                for method, mapper := range possiblesErrors </span><span class="cov0" title="0">{
                        if method == c.Method() || method == "*" </span><span class="cov0" title="0">{
                                for key, value := range mapper </span><span class="cov0" title="0">{
                                        switch pgErr := pgerror.HandlerError(err); </span>{
                                        case errors.Is(pgErr, key):<span class="cov0" title="0">
                                                return HTTPResponse.New(c, value[0].(int), fiberi18n.MustLocalize(c, value[1].(string)), nil)</span>
                                        }
                                }
                        }
                }

                <span class="cov0" title="0">log.Printf("Undected error '%v': %s\n", reflect.TypeOf(err), err.Error())
                return HTTPResponse.New(c, fiber.StatusInternalServerError, fiberi18n.MustLocalize(c, "errGeneric"), nil)</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

import (
        "time"

        "github.com/gofiber/fiber/v2"
)

func NewMiscHandler(miscRoute fiber.Router) <span class="cov0" title="0">{
        handler := &amp;MiscHandler{}

        miscRoute.Get("", handler.healthCheck).Name("Root")
}</span>

type MiscHandler struct{}

// healthCheck godoc
// @Summary      Ping Pong
// @Description  Ping Pong
// @Tags         Ping
// @Produce      json
// @Success      200  {object}   map[string]string
// @Router       / [get]
func (h *MiscHandler) healthCheck(c *fiber.Ctx) error <span class="cov0" title="0">{
        return c.Status(fiber.StatusOK).JSON(&amp;fiber.Map{
                "time": time.Now(),
        })
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package handler

import (
        "github.com/gofiber/contrib/fiberi18n/v2"
        "github.com/gofiber/fiber/v2"
        "gorm.io/gorm"

        "github.com/raulaguila/go-api/internal/api/rest/middleware"
        "github.com/raulaguila/go-api/internal/api/rest/middleware/datatransferobject"
        "github.com/raulaguila/go-api/internal/pkg/HTTPResponse"
        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/internal/pkg/dto"
        "github.com/raulaguila/go-api/pkg/pgerror"
        "github.com/raulaguila/go-api/pkg/pgfilter"
        "github.com/raulaguila/go-api/pkg/utils"
)

var middlewareProductDTO = datatransferobject.New(datatransferobject.Config{
        ContextKey: utils.LocalDTO,
        OnLookup:   datatransferobject.Body,
        Model:      &amp;dto.ProductInputDTO{},
})

type ProductHandler struct {
        productService domain.ProductService
        handlerError   func(*fiber.Ctx, error) error
}

func NewProductHandler(route fiber.Router, ps domain.ProductService) <span class="cov0" title="0">{
        handler := &amp;ProductHandler{
                productService: ps,
                handlerError: newErrorHandler(map[string]map[error][]any{
                        fiber.MethodDelete: {
                                pgerror.ErrForeignKeyViolated: []any{fiber.StatusBadRequest, "productUsed"},
                        },
                        "*": {
                                utils.ErrInvalidID:         []any{fiber.StatusBadRequest, "invalidID"},
                                pgerror.ErrUndefinedColumn: []any{fiber.StatusBadRequest, "undefinedColumn"},
                                pgerror.ErrDuplicatedKey:   []any{fiber.StatusConflict, "productRegistered"},
                                gorm.ErrRecordNotFound:     []any{fiber.StatusNotFound, "productNotFound"},
                        },
                }),
        }

        route.Use(middleware.MidAccess)

        route.Get("", middlewareFilterDTO, handler.getProducts)
        route.Post("", middlewareProductDTO, handler.createProduct)
        route.Get("/:"+utils.ParamID, middlewareIDDTO, handler.getProductByID)
        route.Put("/:"+utils.ParamID, middlewareIDDTO, middlewareProductDTO, handler.updateProduct)
        route.Delete("", middlewareIDsDTO, handler.deleteProducts)
}</span>

// getProducts godoc
// @Summary      List products
// @Description  List products
// @Tags         Product
// @Accept       json
// @Produce      json
// @Param        X-Skip-Auth                header        bool                        false        "Skip auth" enums(true,false) default(true)
// @Param        Accept-Language        header        string                        false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        pgfilter                                query        pgfilter.Filter        false        "Optional Filter"
// @Success      200  {array}           dto.ItemsOutputDTO[dto.ProductOutputDTO]
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /product [get]
// @Security         Bearer
func (s *ProductHandler) getProducts(c *fiber.Ctx) error <span class="cov0" title="0">{
        response, err := s.productService.GetProducts(c.Context(), c.Locals(utils.LocalFilter).(*pgfilter.Filter))
        if err != nil </span><span class="cov0" title="0">{
                return s.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(response)</span>
}

// getProductByID godoc
// @Summary      Get product by ID
// @Description  Get product by ID
// @Tags         Product
// @Accept       json
// @Produce      json
// @Param        X-Skip-Auth                header        bool                                false        "Skip auth" enums(true,false) default(true)
// @Param        Accept-Language        header        string                                false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        id                                        path        dto.IDFilter        true        "Product ID"
// @Success      200  {object}          dto.ProductOutputDTO
// @Failure      400  {object}          HTTPResponse.Response
// @Failure      404  {object}          HTTPResponse.Response
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /product/{id} [get]
// @Security         Bearer
func (s *ProductHandler) getProductByID(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Locals(utils.LocalID).(*dto.IDFilter)
        product, err := s.productService.GetProductByID(c.Context(), id.ID)
        if err != nil </span><span class="cov0" title="0">{
                return s.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(product)</span>
}

// createProduct godoc
// @Summary      Insert product
// @Description  Insert product
// @Tags         Product
// @Accept       json
// @Produce      json
// @Param        X-Skip-Auth                header        bool                                        false        "Skip auth" enums(true,false) default(true)
// @Param        Accept-Language        header        string                                        false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        product                         body        dto.ProductInputDTO                true        "Product model"
// @Success      201  {object}          dto.ProductOutputDTO
// @Failure      400  {object}          HTTPResponse.Response
// @Failure      409  {object}                 HTTPResponse.Response
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /product [post]
// @Security         Bearer
func (s *ProductHandler) createProduct(c *fiber.Ctx) error <span class="cov0" title="0">{
        productDTO, err := s.productService.CreateProduct(c.Context(), c.Locals(utils.LocalDTO).(*dto.ProductInputDTO))
        if err != nil </span><span class="cov0" title="0">{
                return s.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return HTTPResponse.New(c, fiber.StatusCreated, fiberi18n.MustLocalize(c, "productCreated"), productDTO)</span>
}

// updateProduct godoc
// @Summary      Update product by ID
// @Description  Update product by ID
// @Tags         Product
// @Accept       json
// @Produce      json
// @Param        X-Skip-Auth                header        bool                                false        "Skip auth" enums(true,false) default(true)
// @Param        Accept-Language        header        string                                false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        id                                        path    dto.IDFilter                true        "Product ID"
// @Param        product                 body dto.ProductInputDTO true "Product model"
// @Success      200  {object}          dto.ProductOutputDTO
// @Failure      400  {object}          HTTPResponse.Response
// @Failure      404  {object}          HTTPResponse.Response
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /product/{id} [put]
// @Security         Bearer
func (s *ProductHandler) updateProduct(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Locals(utils.LocalID).(*dto.IDFilter)
        productDTO, err := s.productService.UpdateProduct(c.Context(), id.ID, c.Locals(utils.LocalDTO).(*dto.ProductInputDTO))
        if err != nil </span><span class="cov0" title="0">{
                return s.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return HTTPResponse.New(c, fiber.StatusOK, fiberi18n.MustLocalize(c, "productUpdated"), productDTO)</span>
}

// deleteProducts godoc
// @Summary      Delete products by IDs
// @Description  Delete products by IDs
// @Tags         Product
// @Accept       json
// @Produce      json
// @Param        X-Skip-Auth                header        bool                                false        "Skip auth" enums(true,false) default(true)
// @Param        Accept-Language        header        string                                false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        ids                                body        dto.IDsInputDTO                true        "Products ID"
// @Success      204  {object}          HTTPResponse.Response
// @Failure      404  {object}          HTTPResponse.Response
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /product [delete]
// @Security         Bearer
func (s *ProductHandler) deleteProducts(c *fiber.Ctx) error <span class="cov0" title="0">{
        toDelete := c.Locals(utils.LocalID).(*dto.IDsInputDTO)
        if err := s.productService.DeleteProducts(c.Context(), toDelete.IDs); err != nil </span><span class="cov0" title="0">{
                return s.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return HTTPResponse.New(c, fiber.StatusOK, fiberi18n.MustLocalize(c, "productDeleted"), nil)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handler

import (
        "github.com/gofiber/contrib/fiberi18n/v2"
        "github.com/gofiber/fiber/v2"
        "gorm.io/gorm"

        "github.com/raulaguila/go-api/internal/api/rest/middleware"
        "github.com/raulaguila/go-api/internal/api/rest/middleware/datatransferobject"
        "github.com/raulaguila/go-api/internal/pkg/HTTPResponse"
        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/internal/pkg/dto"
        "github.com/raulaguila/go-api/pkg/pgerror"
        "github.com/raulaguila/go-api/pkg/pgfilter"
        "github.com/raulaguila/go-api/pkg/utils"
)

var middlewareProfileDTO = datatransferobject.New(datatransferobject.Config{
        ContextKey: utils.LocalDTO,
        OnLookup:   datatransferobject.Body,
        Model:      &amp;dto.ProfileInputDTO{},
})

type ProfileHandler struct {
        profileService domain.ProfileService
        handlerError   func(*fiber.Ctx, error) error
}

func NewProfileHandler(route fiber.Router, ps domain.ProfileService) <span class="cov0" title="0">{
        handler := &amp;ProfileHandler{
                profileService: ps,
                handlerError: newErrorHandler(map[string]map[error][]any{
                        fiber.MethodDelete: {
                                pgerror.ErrForeignKeyViolated: []any{fiber.StatusBadRequest, "profileUsed"},
                        },
                        "*": {
                                utils.ErrInvalidID:         []any{fiber.StatusBadRequest, "invalidID"},
                                pgerror.ErrUndefinedColumn: []any{fiber.StatusBadRequest, "undefinedColumn"},
                                pgerror.ErrDuplicatedKey:   []any{fiber.StatusConflict, "profileRegistered"},
                                gorm.ErrRecordNotFound:     []any{fiber.StatusNotFound, "profileNotFound"},
                        },
                }),
        }

        route.Use(middleware.MidAccess)

        route.Get("", middlewareFilterDTO, handler.getProfiles)
        route.Post("", middlewareProfileDTO, handler.createProfile)
        route.Get("/:"+utils.ParamID, middlewareIDDTO, handler.getProfile)
        route.Put("/:"+utils.ParamID, middlewareIDDTO, middlewareProfileDTO, handler.updateProfile)
        route.Delete("", middlewareIDsDTO, handler.deleteProfiles)
}</span>

// getProfiles godoc
// @Summary      Get profiles
// @Description  Get profiles
// @Tags         Profile
// @Accept       json
// @Produce      json
// @Param        X-Skip-Auth                header        bool                                false        "Skip auth" enums(true,false) default(true)
// @Param        Accept-Language        header        string                                false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        pgfilter                                query        pgfilter.Filter                false        "Optional Filter"
// @Success      200  {array}           dto.ItemsOutputDTO[dto.ProfileOutputDTO]
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /profile [get]
// @Security         Bearer
func (s *ProfileHandler) getProfiles(c *fiber.Ctx) error <span class="cov0" title="0">{
        response, err := s.profileService.GetProfiles(c.Context(), c.Locals(utils.LocalFilter).(*pgfilter.Filter))
        if err != nil </span><span class="cov0" title="0">{
                return s.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(response)</span>
}

// getProfile godoc
// @Summary      Get profile by ID
// @Description  Get profile by ID
// @Tags         Profile
// @Accept       json
// @Produce      json
// @Param        X-Skip-Auth                header        bool                                false        "Skip auth" enums(true,false) default(true)
// @Param        Accept-Language        header        string                                false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        id                                        path    dto.IDFilter                true        "Profile ID"
// @Success      200  {object}          dto.ProfileOutputDTO
// @Failure      400  {object}          HTTPResponse.Response
// @Failure      404  {object}          HTTPResponse.Response
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /profile/{id} [get]
// @Security         Bearer
func (s *ProfileHandler) getProfile(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Locals(utils.LocalID).(*dto.IDFilter)
        profile, err := s.profileService.GetProfileByID(c.Context(), id.ID)
        if err != nil </span><span class="cov0" title="0">{
                return s.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(profile)</span>
}

// createProfile godoc
// @Summary      Insert profile
// @Description  Insert profile
// @Tags         Profile
// @Accept       json
// @Produce      json
// @Param        X-Skip-Auth                header        bool                                false        "Skip auth" enums(true,false) default(true)
// @Param        Accept-Language        header        string                                false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        profile                        body        dto.ProfileInputDTO        true        "Profile model"
// @Success      201  {object}          dto.ProfileOutputDTO
// @Failure      400  {object}          HTTPResponse.Response
// @Failure      409  {object}          HTTPResponse.Response
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /profile [post]
// @Security         Bearer
func (s *ProfileHandler) createProfile(c *fiber.Ctx) error <span class="cov0" title="0">{
        profileDTO, err := s.profileService.CreateProfile(c.Context(), c.Locals(utils.LocalDTO).(*dto.ProfileInputDTO))
        if err != nil </span><span class="cov0" title="0">{
                return s.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return HTTPResponse.New(c, fiber.StatusCreated, fiberi18n.MustLocalize(c, "profileCreated"), profileDTO)</span>
}

// updateProfile godoc
// @Summary      Update profile
// @Description  Update profile by ID
// @Tags         Profile
// @Accept       json
// @Produce      json
// @Param        X-Skip-Auth                header        bool                                false        "Skip auth" enums(true,false) default(true)
// @Param        Accept-Language        header        string                                false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        id                                        path    dto.IDFilter                true        "Profile ID"
// @Param        profile                        body        dto.ProfileInputDTO true        "Profile model"
// @Success      200  {object}          dto.ProfileOutputDTO
// @Failure      400  {object}          HTTPResponse.Response
// @Failure      404  {object}          HTTPResponse.Response
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /profile/{id} [put]
// @Security         Bearer
func (s *ProfileHandler) updateProfile(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Locals(utils.LocalID).(*dto.IDFilter)
        profileDTO, err := s.profileService.UpdateProfile(c.Context(), id.ID, c.Locals(utils.LocalDTO).(*dto.ProfileInputDTO))
        if err != nil </span><span class="cov0" title="0">{
                return s.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return HTTPResponse.New(c, fiber.StatusOK, fiberi18n.MustLocalize(c, "profileUpdated"), profileDTO)</span>
}

// deleteProfiles godoc
// @Summary      Delete profiles by IDs
// @Description  Delete profiles by IDs
// @Tags         Profile
// @Accept       json
// @Produce      json
// @Param        X-Skip-Auth                header        bool                                false        "Skip auth" enums(true,false) default(true)
// @Param        Accept-Language        header        string                                false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        ids                                body        dto.IDsInputDTO     true        "Profiles ID"
// @Success      204  {object}          HTTPResponse.Response
// @Failure      404  {object}          HTTPResponse.Response
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /profile [delete]
// @Security         Bearer
func (s *ProfileHandler) deleteProfiles(c *fiber.Ctx) error <span class="cov0" title="0">{
        toDelete := c.Locals(utils.LocalID).(*dto.IDsInputDTO)
        if err := s.profileService.DeleteProfiles(c.Context(), toDelete.IDs); err != nil </span><span class="cov0" title="0">{
                return s.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return HTTPResponse.New(c, fiber.StatusOK, fiberi18n.MustLocalize(c, "profileDeleted"), nil)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handler

import (
        "net/url"

        "github.com/gofiber/contrib/fiberi18n/v2"
        "github.com/gofiber/fiber/v2"
        "gorm.io/gorm"

        "github.com/raulaguila/go-api/internal/api/rest/middleware"
        "github.com/raulaguila/go-api/internal/api/rest/middleware/datatransferobject"
        "github.com/raulaguila/go-api/internal/pkg/HTTPResponse"
        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/internal/pkg/dto"
        "github.com/raulaguila/go-api/pkg/pgerror"
        "github.com/raulaguila/go-api/pkg/utils"
)

var middlewareUserDTO = datatransferobject.New(datatransferobject.Config{
        ContextKey: utils.LocalDTO,
        OnLookup:   datatransferobject.Body,
        Model:      &amp;dto.UserInputDTO{},
})

var middlewarePasswordDTO = datatransferobject.New(datatransferobject.Config{
        ContextKey: utils.LocalDTO,
        OnLookup:   datatransferobject.Body,
        Model:      &amp;dto.PasswordInputDTO{},
})

type UserHandler struct {
        userService  domain.UserService
        handlerError func(*fiber.Ctx, error) error
}

func NewUserHandler(route fiber.Router, us domain.UserService) <span class="cov0" title="0">{
        handler := &amp;UserHandler{
                userService: us,
                handlerError: newErrorHandler(map[string]map[error][]any{
                        fiber.MethodPost: {
                                pgerror.ErrForeignKeyViolated: []any{fiber.StatusNotFound, "itemNotFound"},
                        },
                        fiber.MethodPut: {
                                pgerror.ErrForeignKeyViolated: []any{fiber.StatusNotFound, "itemNotFound"},
                        },
                        fiber.MethodDelete: {
                                pgerror.ErrForeignKeyViolated: []any{fiber.StatusBadRequest, "userUsed"},
                        },
                        "*": {
                                utils.ErrInvalidID:           []any{fiber.StatusBadRequest, "invalidID"},
                                pgerror.ErrUndefinedColumn:   []any{fiber.StatusBadRequest, "undefinedColumn"},
                                pgerror.ErrDuplicatedKey:     []any{fiber.StatusConflict, "userRegistered"},
                                utils.ErrUserHasPass:         []any{fiber.StatusBadRequest, "hasPass"},
                                utils.ErrPasswordsDoNotMatch: []any{fiber.StatusBadRequest, "passNotMatch"},
                                gorm.ErrRecordNotFound:       []any{fiber.StatusNotFound, "userNotFound"},
                        },
                }),
        }

        route.Put("/pass", middlewarePasswordDTO, handler.setUserPassword)

        route.Use(middleware.MidAccess)

        route.Delete("/pass", middlewareIDDTO, handler.resetUserPassword)
        route.Get("", middlewareUserFilterDTO, handler.getUsers)
        route.Post("", middlewareUserDTO, handler.createUser)
        route.Get("/:"+utils.ParamID, middlewareIDDTO, handler.getUser)
        route.Put("/:"+utils.ParamID, middlewareIDDTO, middlewareUserDTO, handler.updateUser)
        route.Delete("", middlewareIDsDTO, handler.deleteUser)
}</span>

// getUsers godoc
// @Summary      Get users
// @Description  Get all users
// @Tags         User
// @Accept       json
// @Produce      json
// @Param        X-Skip-Auth                header                bool                                false        "Skip auth" enums(true,false) default(true)
// @Param        Accept-Language        header                string                                false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        pgfilter                        query                dto.UserFilter                false        "Optional Filter"
// @Success      200  {array}           dto.ItemsOutputDTO[dto.UserOutputDTO]
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /user [get]
// @Security         Bearer
func (h *UserHandler) getUsers(c *fiber.Ctx) error <span class="cov0" title="0">{
        response, err := h.userService.GetUsers(c.Context(), c.Locals(utils.LocalFilter).(*dto.UserFilter))
        if err != nil </span><span class="cov0" title="0">{
                return h.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(response)</span>
}

// createUser godoc
// @Summary      Insert user
// @Description  Insert user
// @Tags         User
// @Accept       json
// @Produce      json
// @Param        X-Skip-Auth                header                bool                                false        "Skip auth" enums(true,false) default(true)
// @Param        Accept-Language        header                string                                false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        user                                body                dto.UserInputDTO        true        "User model"
// @Success      201  {object}          dto.UserOutputDTO
// @Failure      400  {object}          HTTPResponse.Response
// @Failure      409  {object}          HTTPResponse.Response
// @Failure      500  {object}                 HTTPResponse.Response
// @Router       /user [post]
// @Security         Bearer
func (h *UserHandler) createUser(c *fiber.Ctx) error <span class="cov0" title="0">{
        userDTO := c.Locals(utils.LocalDTO).(*dto.UserInputDTO)
        user, err := h.userService.CreateUser(c.Context(), userDTO)
        if err != nil </span><span class="cov0" title="0">{
                return h.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return HTTPResponse.New(c, fiber.StatusCreated, fiberi18n.MustLocalize(c, "userCreated"), user)</span>
}

// getUser godoc
// @Summary      Get user
// @Description  Get user by ID
// @Tags         User
// @Accept       json
// @Produce      json
// @Param        X-Skip-Auth                header                bool                                false        "Skip auth" enums(true,false) default(true)
// @Param        Accept-Language        header                string                                false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        id                                        path                dto.IDFilter                true        "User ID"
// @Success      200  {object}          dto.UserOutputDTO
// @Failure      400  {object}          HTTPResponse.Response
// @Failure      404  {object}          HTTPResponse.Response
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /user/{id} [get]
// @Security         Bearer
func (h *UserHandler) getUser(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Locals(utils.LocalID).(*dto.IDFilter)
        user, err := h.userService.GetUserByID(c.Context(), id.ID)
        if err != nil </span><span class="cov0" title="0">{
                return h.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return c.Status(fiber.StatusOK).JSON(user)</span>
}

// updateUser godoc
// @Summary      Update user
// @Description  Update user by ID
// @Tags         User
// @Accept       json
// @Produce      json
// @Param        X-Skip-Auth                header                bool                                false        "Skip auth" enums(true,false) default(true)
// @Param        Accept-Language        header                string                                false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        id                                        path                dto.IDFilter                true        "User ID"
// @Param        user                                body                dto.UserInputDTO        true        "User model"
// @Success      200  {object}          dto.UserOutputDTO
// @Failure      400  {object}          HTTPResponse.Response
// @Failure      404  {object}          HTTPResponse.Response
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /user/{id} [put]
// @Security         Bearer
func (h *UserHandler) updateUser(c *fiber.Ctx) error <span class="cov0" title="0">{
        id := c.Locals(utils.LocalID).(*dto.IDFilter)
        userDTO := c.Locals(utils.LocalDTO).(*dto.UserInputDTO)
        user, err := h.userService.UpdateUser(c.Context(), id.ID, userDTO)
        if err != nil </span><span class="cov0" title="0">{
                return h.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return HTTPResponse.New(c, fiber.StatusOK, fiberi18n.MustLocalize(c, "userUpdated"), user)</span>
}

// deleteUser godoc
// @Summary      Delete user
// @Description  Delete user by ID
// @Tags         User
// @Accept       json
// @Produce      json
// @Param        X-Skip-Auth                header                bool                                false        "Skip auth" enums(true,false) default(true)
// @Param        Accept-Language        header                string                                false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        id                                        body                dto.IDsInputDTO                true        "User ID"
// @Success      204  {object}          nil
// @Failure      404  {object}          HTTPResponse.Response
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /user [delete]
// @Security         Bearer
func (h *UserHandler) deleteUser(c *fiber.Ctx) error <span class="cov0" title="0">{
        toDelete := c.Locals(utils.LocalID).(*dto.IDsInputDTO)
        if err := h.userService.DeleteUsers(c.Context(), toDelete.IDs); err != nil </span><span class="cov0" title="0">{
                return h.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return HTTPResponse.New(c, fiber.StatusOK, fiberi18n.MustLocalize(c, "userDeleted"), nil)</span>
}

// resetUser godoc
// @Summary      Reset user password
// @Description  Reset user password by ID
// @Tags         User
// @Accept       json
// @Produce      json
// @Param        X-Skip-Auth                header                bool                                false        "Skip auth" enums(true,false) default(true)
// @Param        Accept-Language        header                string                                false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        email                                query                string                                true         "User email"
// @Success      200  {object}          nil
// @Failure      404  {object}          HTTPResponse.Response
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /user/pass [delete]
// @Security         Bearer
func (h *UserHandler) resetUserPassword(c *fiber.Ctx) error <span class="cov0" title="0">{
        email, err := url.QueryUnescape(c.Query(utils.ParamMail, ""))
        if err != nil </span><span class="cov0" title="0">{
                return h.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">if err := h.userService.ResetUserPassword(c.Context(), email); err != nil </span><span class="cov0" title="0">{
                return h.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return HTTPResponse.New(c, fiber.StatusOK, fiberi18n.MustLocalize(c, "passReset"), nil)</span>
}

// passwordUser godoc
// @Summary      Set user password
// @Description  Set user password by ID
// @Tags         User
// @Accept       json
// @Produce      json
// @Param        X-Skip-Auth                header                bool                                        false        "Skip auth" enums(true,false) default(true)
// @Param        Accept-Language        header                string                                        false        "Request language" enums(en-US,pt-BR) default(en-US)
// @Param        email                                query                string                                        true        "User email" Format(email)
// @Param        password                        body                dto.PasswordInputDTO        true        "Password model"
// @Success      200  {object}          nil
// @Failure      404  {object}          HTTPResponse.Response
// @Failure      500  {object}          HTTPResponse.Response
// @Router       /user/pass [put]
func (h *UserHandler) setUserPassword(c *fiber.Ctx) error <span class="cov0" title="0">{
        email, err := url.QueryUnescape(c.Query(utils.ParamMail, ""))
        if err != nil </span><span class="cov0" title="0">{
                return h.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">pass := c.Locals(utils.LocalDTO).(*dto.PasswordInputDTO)
        if pass.Password == nil || pass.PasswordConfirm == nil || *pass.Password != *pass.PasswordConfirm </span><span class="cov0" title="0">{
                return h.handlerError(c, utils.ErrPasswordsDoNotMatch)
        }</span>

        <span class="cov0" title="0">if err := h.userService.SetUserPassword(c.Context(), email, pass); err != nil </span><span class="cov0" title="0">{
                return h.handlerError(c, err)
        }</span>

        <span class="cov0" title="0">return HTTPResponse.New(c, fiber.StatusOK, fiberi18n.MustLocalize(c, "passSet"), nil)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "crypto/rsa"
        "errors"
        "log"
        "os"

        "github.com/gofiber/contrib/fiberi18n/v2"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/keyauth"
        "github.com/golang-jwt/jwt/v5"

        "github.com/raulaguila/go-api/internal/pkg/HTTPResponse"
        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/pkg/utils"
)

var (
        MidAccess  fiber.Handler
        MidRefresh fiber.Handler
)

func Auth(parsedKey *rsa.PrivateKey, repo domain.UserRepository) fiber.Handler <span class="cov0" title="0">{
        //decodedKey, err := base64.StdEncoding.DecodeString(base64key)
        //utils.PanicIfErr(err)
        //
        //parsedKey, err := jwt.ParseRSAPublicKeyFromPEM(decodedKey)
        //utils.PanicIfErr(err)

        return keyauth.New(keyauth.Config{
                KeyLookup:  "header:" + fiber.HeaderAuthorization,
                AuthScheme: "Bearer",
                ContextKey: "token",
                Next: func(c *fiber.Ctx) bool </span><span class="cov0" title="0">{
                        // Filter request to skip middleware
                        // true to skip, false to not skip
                        c.Locals(utils.LocalUser, new(domain.User))
                        return os.Getenv("API_ACCEPT_SKIP_AUTH") == "1" &amp;&amp; c.Get("X-Skip-Auth", "false") == "true"
                }</span>,
                SuccessHandler: func(c *fiber.Ctx) error <span class="cov0" title="0">{
                        return c.Next()
                }</span>,
                ErrorHandler: func(c *fiber.Ctx, err error) error <span class="cov0" title="0">{
                        return HTTPResponse.New(c, fiber.StatusUnauthorized, err.Error(), nil)
                }</span>,
                Validator: func(c *fiber.Ctx, key string) (bool, error) <span class="cov0" title="0">{
                        parsedToken, err := jwt.Parse(key, func(token *jwt.Token) (any, error) </span><span class="cov0" title="0">{
                                if _, ok := token.Method.(*jwt.SigningMethodRSA); !ok </span><span class="cov0" title="0">{
                                        return nil, jwt.ErrTokenSignatureInvalid
                                }</span>

                                <span class="cov0" title="0">return parsedKey.Public(), nil</span>
                        })
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                log.Println(err)
                                return false, errors.New(fiberi18n.MustLocalize(c, "errGeneric"))
                        }</span>

                        <span class="cov0" title="0">claims, ok := parsedToken.Claims.(jwt.MapClaims)
                        if !ok || !parsedToken.Valid </span><span class="cov0" title="0">{
                                return false, errors.New("invalid jwt token")
                        }</span>

                        <span class="cov0" title="0">user, err := repo.GetUserByToken(c.Context(), claims["token"].(string))
                        if err != nil </span><span class="cov0" title="0">{
                                log.Println(err)
                                return false, errors.New(fiberi18n.MustLocalize(c, "errGeneric"))
                        }</span>

                        <span class="cov0" title="0">if !user.Auth.Status </span><span class="cov0" title="0">{
                                return false, errors.New(fiberi18n.MustLocalize(c, "disabledUser"))
                        }</span>

                        <span class="cov0" title="0">c.Locals(utils.LocalUser, user)
                        return true, nil</span>
                },
        })
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package datatransferobject

import (
        "reflect"

        "github.com/gofiber/fiber/v2"
)

type Config struct {
        // ContextKey string key to store the dto object into context.
        // Optional. Default: "localDTO".
        ContextKey string

        // OnLookup Lookup value used to indicate where to extract the request's DTO.
        // Optional. Default value Body.
        // Possible values:
        // - Body
        // - Query
        // - Params
        // - Cookie
        OnLookup Lookup

        // Model pointer to struct to parse dto.
        // Optional. Default value *map[string]any.
        Model any

        // Next defines a function to skip middleware.
        // Optional. Default: nil
        Next func(c *fiber.Ctx) bool

        // ErrorHandler defines a function which is executed for an invalid key.
        // It may be used to define a custom error.
        // Optional. Default: 400 err.error()
        ErrorHandler fiber.ErrorHandler
}

// defaultConfig provides the default configuration settings for the application, including context key and error handler_test.
var defaultConfig = Config{
        ContextKey: "localDTO",
        OnLookup:   Body,
        Model:      new(map[string]any),
        Next:       nil,
        ErrorHandler: func(c *fiber.Ctx, err error) error <span class="cov8" title="1">{
                return c.Status(fiber.StatusBadRequest).JSON(&amp;fiber.Map{
                        "code":    fiber.StatusBadRequest,
                        "message": err.Error(),
                })
        }</span>,
}

// isPointerOfStruct checks if the provided interface is a pointer to a struct using reflection.
// It returns true if the input is a pointer pointing to a struct, otherwise false.
func isPointerOfStruct(i any) bool <span class="cov8" title="1">{
        return reflect.ValueOf(i).Kind() == reflect.Ptr &amp;&amp; reflect.TypeOf(i).Elem().Kind() == reflect.Struct
}</span>

// configDefault returns a merged configuration by combining the defaultConfig with the provided custom Config options.
// If no custom Config is provided, it returns the defaultConfig.
// Validates and assigns default values for undefined fields in the provided Config.
func configDefault(config ...Config) Config <span class="cov8" title="1">{
        if len(config) &lt; 1 </span><span class="cov0" title="0">{
                return defaultConfig
        }</span>

        <span class="cov8" title="1">cfg := config[0]
        if cfg.ContextKey == "" </span><span class="cov8" title="1">{
                cfg.ContextKey = defaultConfig.ContextKey
        }</span>
        <span class="cov8" title="1">if cfg.OnLookup &gt; Cookie </span><span class="cov0" title="0">{
                cfg.OnLookup = defaultConfig.OnLookup
        }</span>
        <span class="cov8" title="1">if cfg.Model == nil </span><span class="cov0" title="0">{
                cfg.Model = defaultConfig.Model
        }</span>
        <span class="cov8" title="1">if cfg.OnLookup != Body &amp;&amp; !isPointerOfStruct(cfg.Model) </span><span class="cov0" title="0">{
                panic("model to parse params, queries and cookies must be a pointer of struct")</span>
        }
        <span class="cov8" title="1">if cfg.ErrorHandler == nil </span><span class="cov8" title="1">{
                cfg.ErrorHandler = defaultConfig.ErrorHandler
        }</span>

        <span class="cov8" title="1">return cfg</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package datatransferobject

import (
        "fmt"
        "reflect"

        "github.com/gofiber/fiber/v2"
)

func New(config ...Config) fiber.Handler <span class="cov8" title="1">{
        cfg := configDefault(config...)

        parser := func(c *fiber.Ctx, obj any) (any, error) </span><span class="cov8" title="1">{
                switch cfg.OnLookup </span>{
                case Body:<span class="cov8" title="1">
                        return obj, c.BodyParser(obj)</span>
                case Query:<span class="cov8" title="1">
                        return obj, c.QueryParser(obj)</span>
                case Params:<span class="cov0" title="0">
                        return obj, c.ParamsParser(obj)</span>
                default:<span class="cov0" title="0">
                        return obj, c.CookieParser(obj)</span>
                }
        }

        <span class="cov8" title="1">return func(c *fiber.Ctx) error </span><span class="cov8" title="1">{
                if cfg.Next != nil &amp;&amp; cfg.Next(c) </span><span class="cov0" title="0">{
                        return c.Next()
                }</span>

                <span class="cov8" title="1">var err error
                obj := reflect.New(reflect.TypeOf(cfg.Model).Elem()).Interface()
                obj, err = parser(c, obj)
                if err != nil </span><span class="cov8" title="1">{
                        fmt.Printf("Error mid: %v - %v\n", err, reflect.TypeOf(cfg.Model))
                        return cfg.ErrorHandler(c, err)
                }</span>

                <span class="cov8" title="1">c.Locals(cfg.ContextKey, obj)
                return c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package middleware

import (
        "fmt"
        "log"
        "mime/multipart"
        "path/filepath"
        "slices"

        "github.com/gofiber/contrib/fiberi18n/v2"
        "github.com/gofiber/fiber/v2"

        "github.com/raulaguila/go-api/internal/pkg/HTTPResponse"
        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/pkg/utils"
)

func GetFileFromRequest(formKey string, extensions *[]string) func(c *fiber.Ctx) error <span class="cov0" title="0">{
        return func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                file, err := c.FormFile(formKey)
                if err != nil || (extensions != nil &amp;&amp; !slices.Contains(*extensions, filepath.Ext(file.Filename))) </span><span class="cov0" title="0">{
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Println(err.Error())
                        }</span>
                        <span class="cov0" title="0">return HTTPResponse.New(c, fiber.StatusBadRequest, fiberi18n.MustLocalize(c, "invalidData"), nil)</span>
                }

                <span class="cov0" title="0">f, err := file.Open()
                if err != nil </span><span class="cov0" title="0">{
                        return HTTPResponse.New(c, fiber.StatusBadRequest, fiberi18n.MustLocalize(c, "invalidData"), nil)
                }</span>
                <span class="cov0" title="0">defer func(f multipart.File) </span><span class="cov0" title="0">{
                        if err := f.Close(); err != nil </span><span class="cov0" title="0">{
                                log.Println(err)
                        }</span>
                }(f)

                <span class="cov0" title="0">c.Locals(utils.LocalDTO, &amp;domain.File{
                        Name:      file.Filename,
                        Extension: filepath.Ext(file.Filename),
                        File:      f,
                })
                return c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package rest

import (
        "fmt"
        "os"
        "strings"
        "time"

        "github.com/gofiber/contrib/fiberi18n/v2"
        "github.com/gofiber/fiber/v2"
        "github.com/gofiber/fiber/v2/middleware/cors"
        "github.com/gofiber/fiber/v2/middleware/limiter"
        "github.com/gofiber/fiber/v2/middleware/logger"
        "github.com/gofiber/fiber/v2/middleware/recover"
        "github.com/gofiber/swagger"
        "golang.org/x/text/language"
        "gorm.io/gorm"

        "github.com/raulaguila/go-api/configs"
        "github.com/raulaguila/go-api/docs"
        "github.com/raulaguila/go-api/internal/api/rest/handler"
        "github.com/raulaguila/go-api/internal/api/rest/middleware"
        "github.com/raulaguila/go-api/internal/pkg/HTTPResponse"
        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/internal/pkg/repository"
        "github.com/raulaguila/go-api/internal/pkg/service"
)

var (
        profileRepository domain.ProfileRepository
        userRepository    domain.UserRepository
        productRepository domain.ProductRepository

        profileService domain.ProfileService
        userService    domain.UserService
        authService    domain.AuthService
        productService domain.ProductService
)

func initRepositories(postgresDB *gorm.DB) <span class="cov0" title="0">{
        profileRepository = repository.NewProfileRepository(postgresDB)
        userRepository = repository.NewUserRepository(postgresDB)
        productRepository = repository.NewProductRepository(postgresDB)
}</span>

func initServices() <span class="cov0" title="0">{
        profileService = service.NewProfileService(profileRepository)
        userService = service.NewUserService(userRepository)
        authService = service.NewAuthService(userRepository)
        productService = service.NewProductService(productRepository)
}</span>

func initHandlers(app *fiber.App) <span class="cov0" title="0">{
        // Initialize access middlewares
        middleware.MidAccess = middleware.Auth(configs.AccessPrivateKey, userRepository)
        middleware.MidRefresh = middleware.Auth(configs.RefreshPrivateKey, userRepository)

        // Prepare endpoints for the API.
        handler.NewMiscHandler(app.Group(""))
        handler.NewAuthHandler(app.Group("/auth"), authService)
        handler.NewProfileHandler(app.Group("/profile"), profileService)
        handler.NewUserHandler(app.Group("/user"), userService)
        handler.NewProductHandler(app.Group("/product"), productService)

        // Prepare an endpoint for 'Not Found'.
        app.All("*", func(c *fiber.Ctx) error </span><span class="cov0" title="0">{
                return HTTPResponse.New(c, fiber.StatusNotFound, fiberi18n.MustLocalize(c, "nonExistentRoute"), nil)
        }</span>)
}

func start(app *fiber.App, postgresDB *gorm.DB) <span class="cov0" title="0">{
        if strings.ToLower(os.Getenv("API_SWAGGO")) == "1" </span><span class="cov0" title="0">{
                docs.SwaggerInfo.Version = os.Getenv("SYS_VERSION")

                // Config swagger
                app.Get("/swagger/*", swagger.New(swagger.Config{
                        DisplayRequestDuration: true,
                        DocExpansion:           "none",
                        ValidatorUrl:           "none",
                }))
        }</span>

        <span class="cov0" title="0">initRepositories(postgresDB)
        initServices()
        initHandlers(app)

        panic(app.Listen(":" + os.Getenv("API_PORT")))</span>
}

func New(postgresDB *gorm.DB) <span class="cov0" title="0">{
        app := fiber.New(fiber.Config{
                EnablePrintRoutes:     false,
                Prefork:               os.Getenv("API_ENABLE_PREFORK") == "1",
                CaseSensitive:         true,
                StrictRouting:         true,
                DisableStartupMessage: false,
                AppName:               "Golang template",
                ReduceMemoryUsage:     false,
                ErrorHandler: func(c *fiber.Ctx, err error) error </span><span class="cov0" title="0">{
                        return HTTPResponse.New(c, fiber.StatusInternalServerError, err.Error(), nil)
                }</span>,
                BodyLimit: 50 * 1024 * 1024,
        })

        <span class="cov0" title="0">app.Use(recover.New())

        if strings.ToLower(os.Getenv("API_LOGGER")) == "1" </span><span class="cov0" title="0">{
                app.Use(logger.New(logger.Config{
                        CustomTags: map[string]logger.LogFunc{
                                "xid": func(output logger.Buffer, _ *fiber.Ctx, data *logger.Data, _ string) (int, error) </span><span class="cov0" title="0">{
                                        return output.WriteString(fmt.Sprintf("%6s", data.Pid))
                                }</span>,
                                "fullPath": func(output logger.Buffer, c *fiber.Ctx, _ *logger.Data, _ string) (int, error) <span class="cov0" title="0">{
                                        return output.WriteString(c.OriginalURL())
                                }</span>,
                                "xip": func(output logger.Buffer, c *fiber.Ctx, _ *logger.Data, _ string) (int, error) <span class="cov0" title="0">{
                                        return output.WriteString(fmt.Sprintf("%15s", c.IP()))
                                }</span>,
                                "xauth": func(output logger.Buffer, c *fiber.Ctx, _ *logger.Data, _ string) (int, error) <span class="cov0" title="0">{
                                        if auth := c.Get("Authorization", ""); auth != "" </span><span class="cov0" title="0">{
                                                return output.WriteString(fmt.Sprintf(":%s", strings.TrimPrefix(auth, "Bearer ")[:15]))
                                        }</span>
                                        <span class="cov0" title="0">return output.WriteString("")</span>
                                },
                        },
                        Format:     "[FIBER:${magenta}${xid}${reset}] ${time} | ${status} | ${latency} | ${xip} | ${method} ${fullPath} ${yellow}\"${reqHeader:Accept-Language}${xauth}\"${reset} ${magenta}${error}${reset}\n",
                        TimeFormat: "2006-01-02 15:04:05",
                        TimeZone:   time.Local.String(),
                }))
        }

        <span class="cov0" title="0">app.Use(
                cors.New(cors.Config{
                        AllowOrigins:  "*",
                        AllowMethods:  strings.Join([]string{fiber.MethodGet, fiber.MethodPost, fiber.MethodPut, fiber.MethodDelete, fiber.MethodOptions}, ","),
                        AllowHeaders:  "*",
                        ExposeHeaders: "*",
                        MaxAge:        1,
                }),
                fiberi18n.New(&amp;fiberi18n.Config{
                        Next: func(c *fiber.Ctx) bool </span><span class="cov0" title="0">{
                                return false
                        }</span>,
                        RootPath:        "./locales",
                        AcceptLanguages: []language.Tag{language.AmericanEnglish, language.BrazilianPortuguese},
                        DefaultLanguage: language.AmericanEnglish,
                        Loader:          &amp;fiberi18n.EmbedLoader{FS: configs.Locales},
                }),
                limiter.New(limiter.Config{
                        Max:        100,
                        Expiration: time.Minute,
                        LimitReached: func(c *fiber.Ctx) error <span class="cov0" title="0">{
                                return HTTPResponse.New(c, fiber.StatusTooManyRequests, fiberi18n.MustLocalize(c, "manyRequests"), nil)
                        }</span>,
                }),
        )

        <span class="cov0" title="0">start(app, postgresDB)</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package pgsql

import (
        "fmt"
        "os"
        "time"

        "gorm.io/driver/postgres"
        "gorm.io/gorm"
        "gorm.io/gorm/logger"

        "github.com/raulaguila/go-api/pkg/utils"
)

func ConnectPostgresDB() *gorm.DB <span class="cov0" title="0">{
        uri := fmt.Sprintf("host=%s user=%s password=%s dbname=%v port=%s sslmode=disable TimeZone=%v", os.Getenv("POSTGRES_HOST"), os.Getenv("POSTGRES_USER"), os.Getenv("POSTGRES_PASS"), os.Getenv("POSTGRES_BASE"), os.Getenv("POSTGRES_PORT"), time.Local.String())
        postgresDB, err := gorm.Open(postgres.Open(uri), &amp;gorm.Config{
                Logger:      logger.Default.LogMode(logger.Silent),
                NowFunc:     time.Now,
                PrepareStmt: true,
        })
        utils.PanicIfErr(err)

        return postgresDB
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package HTTPResponse

import "github.com/gofiber/fiber/v2"

type Response struct {
        Code    int    `json:"code" example:"400"`
        Message string `json:"message" example:"status bad request"`
        Object  any    `json:"object,omitempty"`
}

func New(c *fiber.Ctx, status int, message string, object any) error <span class="cov0" title="0">{
        return c.Status(status).JSON(&amp;Response{
                Code:    status,
                Message: message,
                Object:  object,
        })
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package domain

import (
        "context"

        "github.com/raulaguila/go-api/internal/pkg/dto"
)

const AuthTableName string = "users_auth"

type (
        Auth struct {
                Base
                Status    bool `gorm:"column:status;type:bool;not null;"`
                ProfileID uint `gorm:"column:profile_id;type:bigint;not null;index;" validate:"required,min=1"`
                Profile   *Profile
                Token     *string `gorm:"column:token;type:varchar(255);unique;index"`
                Password  *string `gorm:"column:password;type:varchar(255);"`
        }

        AuthService interface {
                Login(context.Context, *dto.AuthInputDTO) (*dto.AuthOutputDTO, error)
                Refresh(*User) *dto.AuthOutputDTO
                Me(*User) *dto.UserOutputDTO
        }
)

func (s *Auth) TableName() string <span class="cov8" title="1">{ return AuthTableName }</span>

func (s *Auth) ToMap() *map[string]any <span class="cov8" title="1">{
        return &amp;map[string]any{
                "status":     s.Status,
                "profile_id": s.ProfileID,
                "token":      s.Token,
                "password":   s.Password,
        }
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package domain

import (
        "context"

        "github.com/raulaguila/packhub"

        "github.com/raulaguila/go-api/internal/pkg/dto"
        "github.com/raulaguila/go-api/pkg/pgfilter"
        "github.com/raulaguila/go-api/pkg/validator"
)

const ProductTableName string = "product"

type (
        Product struct {
                Base
                Name string `gorm:"column:name;type:varchar(100);unique;index;not null;" validate:"required,min=2"`
        }

        ProductRepository interface {
                CountProducts(ctx context.Context, f *pgfilter.Filter) (int64, error)
                GetProducts(ctx context.Context, f *pgfilter.Filter) (*[]Product, error)
                GetProduct(ctx context.Context, p *Product) error
                CreateProduct(ctx context.Context, p *Product) error
                UpdateProduct(ctx context.Context, p *Product) error
                DeleteProducts(ctx context.Context, ids []uint) error
        }

        ProductService interface {
                GenerateProductOutputDTO(*Product) *dto.ProductOutputDTO
                GetProducts(ctx context.Context, f *pgfilter.Filter) (*dto.ItemsOutputDTO[dto.ProductOutputDTO], error)
                GetProductByID(ctx context.Context, id uint) (*dto.ProductOutputDTO, error)
                CreateProduct(ctx context.Context, pdto *dto.ProductInputDTO) (*dto.ProductOutputDTO, error)
                UpdateProduct(ctx context.Context, id uint, pdto *dto.ProductInputDTO) (*dto.ProductOutputDTO, error)
                DeleteProducts(ctx context.Context, ids []uint) error
        }
)

func (s *Product) TableName() string <span class="cov0" title="0">{ return ProductTableName }</span>

func (s *Product) Bind(p *dto.ProductInputDTO) error <span class="cov0" title="0">{
        if p != nil </span><span class="cov0" title="0">{
                s.Name = packhub.PointerValue(p.Name, s.Name)
        }</span>

        <span class="cov0" title="0">return validator.StructValidator.Validate(s)</span>
}

func (s *Product) ToMap() map[string]any <span class="cov0" title="0">{
        return map[string]any{
                "name": s.Name,
        }
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package domain

import (
        "context"

        "github.com/lib/pq"

        "github.com/raulaguila/packhub"

        "github.com/raulaguila/go-api/internal/pkg/dto"
        "github.com/raulaguila/go-api/pkg/pgfilter"
        "github.com/raulaguila/go-api/pkg/validator"
)

const ProfileTableName string = "users_profile"

type (
        Profile struct {
                Base
                Name        string         `gorm:"column:name;type:varchar(100);unique;not null;" validate:"required,min=4"`
                Permissions pq.StringArray `gorm:"column:permissions;type:text[];not null;" validate:"required"`
        }

        ProfileRepository interface {
                CountProfiles(ctx context.Context, f *pgfilter.Filter) (int64, error)
                GetProfile(ctx context.Context, p *Profile) error
                GetProfiles(ctx context.Context, f *pgfilter.Filter) (*[]Profile, error)
                CreateProfile(ctx context.Context, p *Profile) error
                UpdateProfile(ctx context.Context, p *Profile) error
                DeleteProfiles(ctx context.Context, i []uint) error
        }

        ProfileService interface {
                GenerateProfileOutputDTO(p *Profile) *dto.ProfileOutputDTO
                GetProfileByID(ctx context.Context, id uint) (*dto.ProfileOutputDTO, error)
                GetProfiles(ctx context.Context, f *pgfilter.Filter) (*dto.ItemsOutputDTO[dto.ProfileOutputDTO], error)
                CreateProfile(ctx context.Context, pdto *dto.ProfileInputDTO) (*dto.ProfileOutputDTO, error)
                UpdateProfile(ctx context.Context, id uint, pdto *dto.ProfileInputDTO) (*dto.ProfileOutputDTO, error)
                DeleteProfiles(ctx context.Context, ids []uint) error
        }
)

func (s *Profile) TableName() string <span class="cov8" title="1">{
        return ProfileTableName
}</span>

func (s *Profile) ToMap() *map[string]any <span class="cov8" title="1">{
        return &amp;map[string]any{
                "name":        s.Name,
                "permissions": s.Permissions,
        }
}</span>

func (s *Profile) Bind(p *dto.ProfileInputDTO) error <span class="cov8" title="1">{
        if p != nil </span><span class="cov8" title="1">{
                s.Name = packhub.PointerValue(p.Name, s.Name)
                s.Permissions = packhub.PointerValue(p.Permissions, s.Permissions)
        }</span>

        <span class="cov8" title="1">return validator.StructValidator.Validate(s)</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package domain

import (
        "context"
        "crypto/rsa"
        "gorm.io/gorm"
        "io"
        "time"

        "github.com/golang-jwt/jwt/v5"
        "github.com/google/uuid"
        "golang.org/x/crypto/bcrypt"

        "github.com/raulaguila/packhub"

        "github.com/raulaguila/go-api/internal/pkg/dto"
        "github.com/raulaguila/go-api/pkg/utils"
        "github.com/raulaguila/go-api/pkg/validator"
)

const UserTableName string = "users"

type (
        User struct {
                Base
                Name   string `gorm:"column:name;type:varchar(90);not null;" validate:"required,min=5"`
                Email  string `gorm:"column:mail;type:varchar(50);not null;unique;index;" validate:"required,email"`
                AuthID uint   `gorm:"column:auth_id;type:bigint;not null;index;"`
                Auth   *Auth  `gorm:"constraint:OnDelete:CASCADE"`
        }

        File struct {
                Name      string
                Extension string
                File      io.Reader
        }

        UserRepository interface {
                CountUsers(context.Context, *dto.UserFilter) (int64, error)
                GetUsers(context.Context, *dto.UserFilter) (*[]User, error)
                GetUser(context.Context, *User) error
                GetUserByToken(context.Context, string) (*User, error)
                CreateUser(context.Context, *User) error
                UpdateUser(context.Context, *User) error
                DeleteUsers(context.Context, []uint) error
        }

        UserService interface {
                GenerateUserOutputDTO(*User) *dto.UserOutputDTO
                GetUserByID(context.Context, uint) (*dto.UserOutputDTO, error)
                GetUsers(context.Context, *dto.UserFilter) (*dto.ItemsOutputDTO[dto.UserOutputDTO], error)
                CreateUser(context.Context, *dto.UserInputDTO) (*dto.UserOutputDTO, error)
                UpdateUser(context.Context, uint, *dto.UserInputDTO) (*dto.UserOutputDTO, error)
                DeleteUsers(context.Context, []uint) error
                ResetUserPassword(context.Context, string) error
                SetUserPassword(context.Context, string, *dto.PasswordInputDTO) error
        }
)

func (u *User) AfterDelete(tx *gorm.DB) (err error) <span class="cov0" title="0">{
        return tx.Delete(&amp;Auth{}, u.AuthID).Error
}</span>

func (u *User) TableName() string <span class="cov8" title="1">{
        return UserTableName
}</span>

func (u *User) ToMap() *map[string]any <span class="cov8" title="1">{
        return &amp;map[string]any{
                "name":    u.Name,
                "mail":    u.Email,
                "auth_id": u.AuthID,
                "Auth": map[string]any{
                        "status":     u.Auth.Status,
                        "profile_id": u.Auth.ProfileID,
                        "token":      u.Auth.Token,
                        "password":   u.Auth.Password,
                },
        }
}</span>

func (u *User) Bind(p *dto.UserInputDTO) error <span class="cov8" title="1">{
        if p != nil </span><span class="cov8" title="1">{
                u.Name = packhub.PointerValue(p.Name, u.Name)
                u.Email = packhub.PointerValue(p.Email, u.Email)
                u.Auth.Status = packhub.PointerValue(p.Status, u.Auth.Status)
                u.Auth.ProfileID = packhub.PointerValue(p.ProfileID, u.Auth.ProfileID)
        }</span>

        <span class="cov8" title="1">return validator.StructValidator.Validate(u)</span>
}

func (u *User) SetPassword(password string) error <span class="cov0" title="0">{
        hash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">u.Auth.Token = packhub.Pointer(uuid.New().String())
        u.Auth.Password = packhub.Pointer(string(hash))

        return nil</span>
}

func (u *User) ResetPassword() <span class="cov0" title="0">{
        u.Auth.Token = nil
        u.Auth.Password = nil
}</span>

func (u *User) ValidatePassword(password string) bool <span class="cov8" title="1">{
        if u.Auth.Password == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return bcrypt.CompareHashAndPassword([]byte(*u.Auth.Password), []byte(password)) == nil</span>
}

func (u *User) GenerateToken(expire string, parsedToken *rsa.PrivateKey) (string, error) <span class="cov0" title="0">{
        life, err := utils.DurationFromString(expire, time.Minute)
        claims := jwt.MapClaims{
                "token":  u.Auth.Token,
                "expire": err == nil,
                "iat":    time.Now().Unix(),
        }
        if err == nil </span><span class="cov0" title="0">{
                claims["exp"] = time.Now().Add(life).Unix()
        }</span>

        <span class="cov0" title="0">return jwt.NewWithClaims(jwt.SigningMethodRS256, claims).SignedString(parsedToken)</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package mocks

import (
        "context"

        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/internal/pkg/dto"
        "github.com/stretchr/testify/mock"
)

func NewAuthServiceMock() domain.AuthService <span class="cov0" title="0">{
        return new(AuthServiceMock)
}</span>

type AuthServiceMock struct {
        mock.Mock
}

func (m *AuthServiceMock) Login(ctx context.Context, input *dto.AuthInputDTO) (*dto.AuthOutputDTO, error) <span class="cov0" title="0">{
        args := m.Called(ctx, input)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*dto.AuthOutputDTO), args.Error(1)</span>
}

func (m *AuthServiceMock) Refresh(user *domain.User) *dto.AuthOutputDTO <span class="cov0" title="0">{
        args := m.Called(user)
        return args.Get(0).(*dto.AuthOutputDTO)
}</span>

func (m *AuthServiceMock) Me(user *domain.User) *dto.UserOutputDTO <span class="cov0" title="0">{
        args := m.Called(user)
        return args.Get(0).(*dto.UserOutputDTO)
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package mocks

import (
        "context"

        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/pkg/pgfilter"
        "github.com/stretchr/testify/mock"
)

func NewProductRepositoryMock() domain.ProductRepository <span class="cov0" title="0">{
        return new(ProductRepositoryMock)
}</span>

type ProductRepositoryMock struct {
        mock.Mock
}

func (s *ProductRepositoryMock) CountProducts(ctx context.Context, f *pgfilter.Filter) (int64, error) <span class="cov0" title="0">{
        ret := s.Called(ctx, f)
        return ret.Get(0).(int64), ret.Error(1)
}</span>

func (s *ProductRepositoryMock) GetProduct(ctx context.Context, product *domain.Product) error <span class="cov0" title="0">{
        ret := s.Called(ctx, product)
        return ret.Error(0)
}</span>

func (s *ProductRepositoryMock) GetProducts(ctx context.Context, f *pgfilter.Filter) (*[]domain.Product, error) <span class="cov0" title="0">{
        ret := s.Called(ctx, f)
        return ret.Get(0).(*[]domain.Product), ret.Error(1)
}</span>

func (s *ProductRepositoryMock) CreateProduct(ctx context.Context, product *domain.Product) error <span class="cov0" title="0">{
        ret := s.Called(ctx, product)
        return ret.Error(0)
}</span>

func (s *ProductRepositoryMock) UpdateProduct(ctx context.Context, product *domain.Product) error <span class="cov0" title="0">{
        ret := s.Called(ctx, product)
        return ret.Error(0)
}</span>

func (s *ProductRepositoryMock) DeleteProducts(ctx context.Context, productIDs []uint) error <span class="cov0" title="0">{
        ret := s.Called(ctx, productIDs)
        return ret.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package mocks

import (
        "context"

        "github.com/stretchr/testify/mock"

        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/internal/pkg/dto"
        "github.com/raulaguila/go-api/pkg/pgfilter"
)

func NewProductServiceMock() domain.ProductService <span class="cov0" title="0">{
        return new(ProductServiceMock)
}</span>

type ProductServiceMock struct {
        mock.Mock
}

func (s *ProductServiceMock) GenerateProductOutputDTO(product *domain.Product) *dto.ProductOutputDTO <span class="cov0" title="0">{
        return &amp;dto.ProductOutputDTO{
                ID:   &amp;product.ID,
                Name: &amp;product.Name,
        }
}</span>

func (s *ProductServiceMock) GetProductByID(ctx context.Context, productID uint) (*dto.ProductOutputDTO, error) <span class="cov0" title="0">{
        ret := s.Called(ctx, productID)
        if ret.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, ret.Error(1)
        }</span>
        <span class="cov0" title="0">return ret.Get(0).(*dto.ProductOutputDTO), ret.Error(1)</span>
}

func (s *ProductServiceMock) GetProducts(ctx context.Context, f *pgfilter.Filter) (*dto.ItemsOutputDTO[dto.ProductOutputDTO], error) <span class="cov0" title="0">{
        ret := s.Called(ctx, f)
        if ret.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, ret.Error(1)
        }</span>
        <span class="cov0" title="0">return ret.Get(0).(*dto.ItemsOutputDTO[dto.ProductOutputDTO]), ret.Error(1)</span>
}

func (s *ProductServiceMock) CreateProduct(ctx context.Context, productDTO *dto.ProductInputDTO) (*dto.ProductOutputDTO, error) <span class="cov0" title="0">{
        ret := s.Called(ctx, productDTO)
        if ret.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, ret.Error(1)
        }</span>

        <span class="cov0" title="0">return ret.Get(0).(*dto.ProductOutputDTO), ret.Error(1)</span>
}

func (s *ProductServiceMock) UpdateProduct(ctx context.Context, productID uint, productDTO *dto.ProductInputDTO) (*dto.ProductOutputDTO, error) <span class="cov0" title="0">{
        ret := s.Called(ctx, productID, productDTO)
        if ret.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, ret.Error(1)
        }</span>

        <span class="cov0" title="0">return ret.Get(0).(*dto.ProductOutputDTO), ret.Error(1)</span>
}

func (s *ProductServiceMock) DeleteProducts(ctx context.Context, productIDs []uint) error <span class="cov0" title="0">{
        ret := s.Called(ctx, productIDs)
        return ret.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package mocks

import (
        "context"

        "github.com/stretchr/testify/mock"

        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/pkg/pgfilter"
)

func NewProfileRepositoryMock() domain.ProfileRepository <span class="cov0" title="0">{
        return new(ProfileRepositoryMock)
}</span>

type ProfileRepositoryMock struct {
        mock.Mock
}

func (s *ProfileRepositoryMock) CountProfiles(ctx context.Context, f *pgfilter.Filter) (int64, error) <span class="cov0" title="0">{
        ret := s.Called(ctx, f)
        return ret.Get(0).(int64), ret.Error(1)
}</span>

func (s *ProfileRepositoryMock) GetProfile(ctx context.Context, profile *domain.Profile) error <span class="cov0" title="0">{
        ret := s.Called(ctx, profile)
        return ret.Error(0)
}</span>

func (s *ProfileRepositoryMock) GetProfiles(ctx context.Context, f *pgfilter.Filter) (*[]domain.Profile, error) <span class="cov0" title="0">{
        ret := s.Called(ctx, f)
        if ret.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, ret.Error(1)
        }</span>
        <span class="cov0" title="0">return ret.Get(0).(*[]domain.Profile), ret.Error(1)</span>
}

func (s *ProfileRepositoryMock) CreateProfile(ctx context.Context, profile *domain.Profile) error <span class="cov0" title="0">{
        ret := s.Called(ctx, profile)
        return ret.Error(0)
}</span>

func (s *ProfileRepositoryMock) UpdateProfile(ctx context.Context, profile *domain.Profile) error <span class="cov0" title="0">{
        ret := s.Called(ctx, profile)
        return ret.Error(0)
}</span>

func (s *ProfileRepositoryMock) DeleteProfiles(ctx context.Context, profileIDs []uint) error <span class="cov0" title="0">{
        ret := s.Called(ctx, profileIDs)
        return ret.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package mocks

import (
        "context"

        "github.com/stretchr/testify/mock"

        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/internal/pkg/dto"
        "github.com/raulaguila/go-api/pkg/pgfilter"
)

func NewProfileServiceMock() domain.ProfileService <span class="cov0" title="0">{
        return new(ProfileServiceMock)
}</span>

type ProfileServiceMock struct {
        mock.Mock
}

func (m *ProfileServiceMock) GenerateProfileOutputDTO(profile *domain.Profile) *dto.ProfileOutputDTO <span class="cov0" title="0">{
        args := m.Called(profile)
        return args.Get(0).(*dto.ProfileOutputDTO)
}</span>

func (m *ProfileServiceMock) GetProfileByID(ctx context.Context, id uint) (*dto.ProfileOutputDTO, error) <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>

        <span class="cov0" title="0">return args.Get(0).(*dto.ProfileOutputDTO), args.Error(1)</span>
}

func (m *ProfileServiceMock) GetProfiles(ctx context.Context, filter *pgfilter.Filter) (*dto.ItemsOutputDTO[dto.ProfileOutputDTO], error) <span class="cov0" title="0">{
        args := m.Called(ctx, filter)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>

        <span class="cov0" title="0">return args.Get(0).(*dto.ItemsOutputDTO[dto.ProfileOutputDTO]), args.Error(1)</span>
}

func (m *ProfileServiceMock) CreateProfile(ctx context.Context, input *dto.ProfileInputDTO) (*dto.ProfileOutputDTO, error) <span class="cov0" title="0">{
        args := m.Called(ctx, input)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>

        <span class="cov0" title="0">return args.Get(0).(*dto.ProfileOutputDTO), args.Error(1)</span>
}

func (m *ProfileServiceMock) UpdateProfile(ctx context.Context, id uint, input *dto.ProfileInputDTO) (*dto.ProfileOutputDTO, error) <span class="cov0" title="0">{
        args := m.Called(ctx, id, input)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>

        <span class="cov0" title="0">return args.Get(0).(*dto.ProfileOutputDTO), args.Error(1)</span>
}

func (m *ProfileServiceMock) DeleteProfiles(ctx context.Context, ids []uint) error <span class="cov0" title="0">{
        args := m.Called(ctx, ids)
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package mocks

import (
        "context"

        "github.com/stretchr/testify/mock"

        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/internal/pkg/dto"
)

func NewUserRepositoryMock() domain.UserRepository <span class="cov0" title="0">{
        return new(UserRepositoryMock)
}</span>

type UserRepositoryMock struct {
        mock.Mock
}

func (m *UserRepositoryMock) GetUser(ctx context.Context, user *domain.User) error <span class="cov0" title="0">{
        user.Name = "John Doe"
        user.Email = "johndoe@example.com"
        user.Auth = &amp;domain.Auth{
                Status: false,
                Profile: &amp;domain.Profile{
                        Base: domain.Base{ID: uint(1)},
                        Name: "ADMIN",
                },
        }
        args := m.Called(ctx, user)
        return args.Error(0)
}</span>

func (m *UserRepositoryMock) GetUserByToken(ctx context.Context, token string) (*domain.User, error) <span class="cov0" title="0">{
        args := m.Called(ctx, token)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*domain.User), args.Error(1)</span>
}

func (m *UserRepositoryMock) GetUsers(ctx context.Context, userFilter *dto.UserFilter) (*[]domain.User, error) <span class="cov0" title="0">{
        args := m.Called(ctx, userFilter)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*[]domain.User), args.Error(1)</span>
}

func (m *UserRepositoryMock) CountUsers(ctx context.Context, userFilter *dto.UserFilter) (int64, error) <span class="cov0" title="0">{
        args := m.Called(ctx, userFilter)
        return args.Get(0).(int64), args.Error(1)
}</span>

func (m *UserRepositoryMock) CreateUser(ctx context.Context, user *domain.User) error <span class="cov0" title="0">{
        user.ID = 1
        user.Name = "John Doe"
        user.Email = "johndoe@example.com"
        user.Auth = &amp;domain.Auth{Status: true, Profile: &amp;domain.Profile{Base: domain.Base{ID: 1}, Name: "ADMIN"}}

        args := m.Called(ctx, user)
        return args.Error(0)
}</span>

func (m *UserRepositoryMock) UpdateUser(ctx context.Context, user *domain.User) error <span class="cov0" title="0">{
        args := m.Called(ctx, user)
        return args.Error(0)
}</span>

func (m *UserRepositoryMock) DeleteUsers(ctx context.Context, ids []uint) error <span class="cov0" title="0">{
        args := m.Called(ctx, ids)
        return args.Error(0)
}</span>

func (m *UserRepositoryMock) ResetUserPassword(ctx context.Context, user *domain.User) error <span class="cov0" title="0">{
        args := m.Called(ctx, user)
        return args.Error(0)
}</span>

func (m *UserRepositoryMock) SetUserPassword(ctx context.Context, user *domain.User, pass *dto.PasswordInputDTO) error <span class="cov0" title="0">{
        args := m.Called(ctx, user, pass)
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">package mocks

import (
        "context"

        "github.com/stretchr/testify/mock"

        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/internal/pkg/dto"
)

func NewUserServiceMock() domain.UserService <span class="cov0" title="0">{
        return new(UserServiceMock)
}</span>

type UserServiceMock struct {
        mock.Mock
}

func (m *UserServiceMock) GenerateUserOutputDTO(profile *domain.User) *dto.UserOutputDTO <span class="cov0" title="0">{
        args := m.Called(profile)
        return args.Get(0).(*dto.UserOutputDTO)
}</span>

func (m *UserServiceMock) GenerateUserPhotoURL(ctx context.Context, userID uint) (string, error) <span class="cov0" title="0">{
        args := m.Called(ctx, userID)
        return args.String(0), args.Error(1)
}</span>

func (m *UserServiceMock) SetUserPhoto(ctx context.Context, userID uint, file *domain.File) error <span class="cov0" title="0">{
        args := m.Called(ctx, userID, file)
        return args.Error(0)
}</span>

func (m *UserServiceMock) GetUsers(ctx context.Context, filter *dto.UserFilter) (*dto.ItemsOutputDTO[dto.UserOutputDTO], error) <span class="cov0" title="0">{
        args := m.Called(ctx, filter)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*dto.ItemsOutputDTO[dto.UserOutputDTO]), args.Error(1)</span>
}

func (m *UserServiceMock) CreateUser(ctx context.Context, userInput *dto.UserInputDTO) (*dto.UserOutputDTO, error) <span class="cov0" title="0">{
        args := m.Called(ctx, userInput)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*dto.UserOutputDTO), args.Error(1)</span>
}

func (m *UserServiceMock) GetUserByID(ctx context.Context, userID uint) (*dto.UserOutputDTO, error) <span class="cov0" title="0">{
        args := m.Called(ctx, userID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*dto.UserOutputDTO), args.Error(1)</span>
}

func (m *UserServiceMock) UpdateUser(ctx context.Context, userID uint, userInput *dto.UserInputDTO) (*dto.UserOutputDTO, error) <span class="cov0" title="0">{
        args := m.Called(ctx, userID, userInput)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*dto.UserOutputDTO), args.Error(1)</span>
}

func (m *UserServiceMock) DeleteUsers(ctx context.Context, userIDs []uint) error <span class="cov0" title="0">{
        args := m.Called(ctx, userIDs)
        return args.Error(0)
}</span>

func (m *UserServiceMock) ResetUserPassword(ctx context.Context, email string) error <span class="cov0" title="0">{
        args := m.Called(ctx, email)
        return args.Error(0)
}</span>

func (m *UserServiceMock) SetUserPassword(ctx context.Context, email string, passwordInput *dto.PasswordInputDTO) error <span class="cov0" title="0">{
        args := m.Called(ctx, email, passwordInput)
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package repository

import (
        "context"

        "gorm.io/gorm"

        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/pkg/pgfilter"
)

func NewProductRepository(db *gorm.DB) domain.ProductRepository <span class="cov0" title="0">{
        return &amp;productRepository{
                db: db,
        }
}</span>

type productRepository struct {
        db *gorm.DB
}

func (s *productRepository) applyFilter(ctx context.Context, f *pgfilter.Filter) *gorm.DB <span class="cov0" title="0">{
        db := s.db.WithContext(ctx)
        if f != nil </span><span class="cov0" title="0">{
                if where := f.ApplySearchLike("name"); where != "" </span><span class="cov0" title="0">{
                        db = db.Where(where)
                }</span>
                <span class="cov0" title="0">db = db.Order(f.ApplyOrder(nil))</span>
        }

        <span class="cov0" title="0">return db</span>
}

func (s *productRepository) CountProducts(ctx context.Context, f *pgfilter.Filter) (int64, error) <span class="cov0" title="0">{
        var count int64
        return count, s.applyFilter(ctx, f).Model(new(domain.Product)).Count(&amp;count).Error
}</span>

func (s *productRepository) GetProducts(ctx context.Context, f *pgfilter.Filter) (*[]domain.Product, error) <span class="cov0" title="0">{
        db := s.applyFilter(ctx, f)
        if f != nil </span><span class="cov0" title="0">{
                if ok, offset, limit := f.ApplyPagination(); ok </span><span class="cov0" title="0">{
                        db = db.Offset(offset).Limit(limit)
                }</span>
        }

        <span class="cov0" title="0">products := new([]domain.Product)
        return products, db.Find(products).Error</span>
}

func (s *productRepository) GetProduct(ctx context.Context, p *domain.Product) error <span class="cov0" title="0">{
        return s.db.WithContext(ctx).Where(p).First(p).Error
}</span>

func (s *productRepository) CreateProduct(ctx context.Context, p *domain.Product) error <span class="cov0" title="0">{
        return s.db.WithContext(ctx).Create(p).Error
}</span>

func (s *productRepository) UpdateProduct(ctx context.Context, p *domain.Product) error <span class="cov0" title="0">{
        return s.db.WithContext(ctx).Model(p).Updates(p.ToMap()).Error
}</span>

func (s *productRepository) DeleteProducts(ctx context.Context, i []uint) error <span class="cov0" title="0">{
        return s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                result := tx.Delete(new(domain.Product), i)
                if result.Error != nil </span><span class="cov0" title="0">{
                        return result.Error
                }</span>
                <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                        return gorm.ErrRecordNotFound
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package repository

import (
        "context"

        "gorm.io/gorm"

        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/pkg/pgfilter"
)

func NewProfileRepository(db *gorm.DB) domain.ProfileRepository <span class="cov0" title="0">{
        return &amp;profileRepository{
                db: db,
        }
}</span>

type profileRepository struct {
        db *gorm.DB
}

func (s *profileRepository) applyFilter(ctx context.Context, f *pgfilter.Filter) *gorm.DB <span class="cov0" title="0">{
        db := s.db.WithContext(ctx)
        if f != nil </span><span class="cov0" title="0">{
                if where := f.ApplySearchLike("name"); where != "" </span><span class="cov0" title="0">{
                        db = db.Where(where)
                }</span>
                <span class="cov0" title="0">db = db.Order(f.ApplyOrder(nil))</span>
        }

        <span class="cov0" title="0">return db</span>
}

func (s *profileRepository) CountProfiles(ctx context.Context, f *pgfilter.Filter) (int64, error) <span class="cov0" title="0">{
        var count int64
        return count, s.applyFilter(ctx, f).Model(new(domain.Profile)).Count(&amp;count).Error
}</span>

func (s *profileRepository) GetProfiles(ctx context.Context, f *pgfilter.Filter) (*[]domain.Profile, error) <span class="cov0" title="0">{
        db := s.applyFilter(ctx, f)
        if f != nil </span><span class="cov0" title="0">{
                if ok, offset, limit := f.ApplyPagination(); ok </span><span class="cov0" title="0">{
                        db = db.Offset(offset).Limit(limit)
                }</span>
        }

        <span class="cov0" title="0">profiles := new([]domain.Profile)
        return profiles, db.Find(profiles).Error</span>
}

func (s *profileRepository) GetProfile(ctx context.Context, p *domain.Profile) error <span class="cov0" title="0">{
        return s.db.WithContext(ctx).Where(p).First(p).Error
}</span>

func (s *profileRepository) CreateProfile(ctx context.Context, p *domain.Profile) error <span class="cov0" title="0">{
        return s.db.WithContext(ctx).Create(p).Error
}</span>

func (s *profileRepository) UpdateProfile(ctx context.Context, p *domain.Profile) error <span class="cov0" title="0">{
        return s.db.WithContext(ctx).Model(p).Updates(p.ToMap()).Error
}</span>

func (s *profileRepository) DeleteProfiles(ctx context.Context, ids []uint) error <span class="cov0" title="0">{
        return s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                result := tx.Delete(new(domain.Profile), ids)
                if result.Error != nil </span><span class="cov0" title="0">{
                        return result.Error
                }</span>
                <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                        return gorm.ErrRecordNotFound
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package repository

import (
        "context"
        "fmt"

        "gorm.io/gorm"
        "gorm.io/gorm/clause"

        "github.com/raulaguila/packhub"

        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/internal/pkg/dto"
        "github.com/raulaguila/go-api/pkg/utils"
)

func NewUserRepository(db *gorm.DB) domain.UserRepository <span class="cov0" title="0">{
        return &amp;userRepository{
                db: db,
        }
}</span>

type userRepository struct {
        db *gorm.DB
}

func (s *userRepository) applyFilter(ctx context.Context, f *dto.UserFilter) *gorm.DB <span class="cov0" title="0">{
        db := s.db.WithContext(ctx)
        if f != nil </span><span class="cov0" title="0">{
                if f.ProfileID != 0 </span><span class="cov0" title="0">{
                        db = db.Where(domain.AuthTableName+".profile_id = ?", f.ProfileID)
                }</span>
                <span class="cov0" title="0">db = db.Joins(fmt.Sprintf("JOIN %v ON %v.id = %v.auth_id", domain.AuthTableName, domain.AuthTableName, domain.UserTableName))
                db = db.Joins(fmt.Sprintf("JOIN %v ON %v.id = %v.profile_id", domain.ProfileTableName, domain.ProfileTableName, domain.AuthTableName))
                if where := f.ApplySearchLike(
                        domain.UserTableName+".name",
                        domain.UserTableName+".mail",
                        domain.ProfileTableName+".name",
                ); where != "" </span><span class="cov0" title="0">{
                        db = db.Where(where)
                }</span>
                <span class="cov0" title="0">db = db.Order(f.ApplyOrder(packhub.Pointer(domain.UserTableName)))</span>
        }

        <span class="cov0" title="0">return db.Group(domain.UserTableName + ".id")</span>
}

func (s *userRepository) CountUsers(ctx context.Context, f *dto.UserFilter) (int64, error) <span class="cov0" title="0">{
        var count int64
        return count, s.applyFilter(ctx, f).Model(new(domain.User)).Count(&amp;count).Error
}</span>

func (s *userRepository) GetUsers(ctx context.Context, f *dto.UserFilter) (*[]domain.User, error) <span class="cov0" title="0">{
        db := s.applyFilter(ctx, f)
        if f != nil </span><span class="cov0" title="0">{
                if ok, offset, limit := f.ApplyPagination(); ok </span><span class="cov0" title="0">{
                        db = db.Offset(offset).Limit(limit)
                }</span>
        }

        <span class="cov0" title="0">users := new([]domain.User)
        return users, db.Preload(utils.PGAuthProfile).Find(users).Error</span>
}

func (s *userRepository) GetUser(ctx context.Context, user *domain.User) error <span class="cov0" title="0">{
        return s.db.WithContext(ctx).Where(user).Preload(utils.PGAuthProfile).First(user).Error
}</span>

func (s *userRepository) GetUserByToken(ctx context.Context, token string) (*domain.User, error) <span class="cov0" title="0">{
        user := new(domain.User)
        return user, s.db.
                WithContext(ctx).
                Joins(fmt.Sprintf("JOIN %v ON %v.id = %v.auth_id", domain.AuthTableName, domain.AuthTableName, domain.UserTableName)).
                Preload(utils.PGAuthProfile).
                First(user, domain.AuthTableName+".token = ?", token).Error
}</span>

func (s *userRepository) CreateUser(ctx context.Context, user *domain.User) error <span class="cov0" title="0">{
        return s.db.Session(&amp;gorm.Session{FullSaveAssociations: true}).WithContext(ctx).Create(user).Error
}</span>

func (s *userRepository) UpdateUser(ctx context.Context, user *domain.User) error <span class="cov0" title="0">{
        return s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                if err := s.db.Model(user.Auth).Updates(user.Auth.ToMap()).Error; err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return s.db.Model(user).Updates(user.ToMap()).Error</span>
        })
}

func (s *userRepository) DeleteUsers(ctx context.Context, toDelete []uint) error <span class="cov0" title="0">{
        users := new([]domain.User)
        if err := s.db.WithContext(ctx).Find(users, toDelete).Error; err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if len(*users) == 0 </span><span class="cov0" title="0">{
                return gorm.ErrRecordNotFound
        }</span>

        <span class="cov0" title="0">return s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                result := tx.Select(clause.Associations).Where(users).Delete(users)
                if result.Error != nil </span><span class="cov0" title="0">{
                        return result.Error
                }</span>
                <span class="cov0" title="0">if result.RowsAffected == 0 </span><span class="cov0" title="0">{
                        return gorm.ErrRecordNotFound
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package service

import (
        "context"
        "os"

        "github.com/raulaguila/go-api/configs"
        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/internal/pkg/dto"
        "github.com/raulaguila/go-api/pkg/utils"
)

func NewAuthService(r domain.UserRepository) domain.AuthService <span class="cov0" title="0">{
        return &amp;authService{
                userRepository: r,
        }
}</span>

type authService struct {
        userRepository domain.UserRepository
}

func (s *authService) generateUserOutputDTO(user *domain.User) *dto.UserOutputDTO <span class="cov0" title="0">{
        if user == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return &amp;dto.UserOutputDTO{
                ID:     &amp;user.ID,
                Name:   &amp;user.Name,
                Email:  &amp;user.Email,
                Status: &amp;user.Auth.Status,
                Profile: &amp;dto.ProfileOutputDTO{
                        ID:          &amp;user.Auth.Profile.ID,
                        Name:        &amp;user.Auth.Profile.Name,
                        Permissions: &amp;user.Auth.Profile.Permissions,
                },
        }</span>
}

func (s *authService) generateAuthOutputDTO(user *domain.User) *dto.AuthOutputDTO <span class="cov0" title="0">{
        accessToken, _ := user.GenerateToken(os.Getenv("ACCESS_TOKEN_EXPIRE"), configs.AccessPrivateKey)
        refreshToken, _ := user.GenerateToken(os.Getenv("RFRESH_TOKEN_EXPIRE"), configs.RefreshPrivateKey)

        return &amp;dto.AuthOutputDTO{
                User:         s.generateUserOutputDTO(user),
                AccessToken:  accessToken,
                RefreshToken: refreshToken,
        }
}</span>

func (s *authService) Login(ctx context.Context, credentials *dto.AuthInputDTO) (*dto.AuthOutputDTO, error) <span class="cov0" title="0">{
        user := &amp;domain.User{Email: credentials.Login}
        if err := s.userRepository.GetUser(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !user.ValidatePassword(credentials.Password) </span><span class="cov0" title="0">{
                return nil, utils.ErrInvalidCredentials
        }</span>

        <span class="cov0" title="0">if !user.Auth.Status || user.Auth.Password == nil </span><span class="cov0" title="0">{
                return nil, utils.ErrDisabledUser
        }</span>

        <span class="cov0" title="0">return s.generateAuthOutputDTO(user), nil</span>
}

func (s *authService) Me(user *domain.User) *dto.UserOutputDTO <span class="cov0" title="0">{
        return s.generateUserOutputDTO(user)
}</span>

func (s *authService) Refresh(user *domain.User) *dto.AuthOutputDTO <span class="cov0" title="0">{
        return s.generateAuthOutputDTO(user)
}</span>
</pre>
		
		<pre class="file" id="file33" style="display: none">package service

import (
        "context"

        "github.com/raulaguila/packhub"

        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/internal/pkg/dto"
        "github.com/raulaguila/go-api/pkg/pgfilter"
)

func NewProductService(r domain.ProductRepository) domain.ProductService <span class="cov0" title="0">{
        return &amp;productService{
                productRepository: r,
        }
}</span>

type productService struct {
        productRepository domain.ProductRepository
}

func (s *productService) GenerateProductOutputDTO(p *domain.Product) *dto.ProductOutputDTO <span class="cov0" title="0">{
        return &amp;dto.ProductOutputDTO{
                ID:   &amp;p.ID,
                Name: &amp;p.Name,
        }
}</span>

func (s *productService) GetProductByID(ctx context.Context, id uint) (*dto.ProductOutputDTO, error) <span class="cov0" title="0">{
        p := &amp;domain.Product{Base: domain.Base{ID: id}}
        if err := s.productRepository.GetProduct(ctx, p); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.GenerateProductOutputDTO(p), nil</span>
}

func (s *productService) GetProducts(ctx context.Context, f *pgfilter.Filter) (*dto.ItemsOutputDTO[dto.ProductOutputDTO], error) <span class="cov0" title="0">{
        products, err := s.productRepository.GetProducts(ctx, f)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">count, err := s.productRepository.CountProducts(ctx, f)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">outputProducts := make([]dto.ProductOutputDTO, len(*products))
        for i, product := range *products </span><span class="cov0" title="0">{
                outputProducts[i] = *s.GenerateProductOutputDTO(&amp;product)
        }</span>

        <span class="cov0" title="0">return &amp;dto.ItemsOutputDTO[dto.ProductOutputDTO]{
                Items: outputProducts,
                Pagination: dto.PaginationDTO{
                        CurrentPage: uint(packhub.Max(f.Page, 1)),
                        PageSize:    uint(packhub.Max(f.Limit, len(outputProducts))),
                        TotalItems:  uint(count),
                        TotalPages:  uint(f.CalcPages(count)),
                },
        }, nil</span>
}

func (s *productService) CreateProduct(ctx context.Context, pdto *dto.ProductInputDTO) (*dto.ProductOutputDTO, error) <span class="cov0" title="0">{
        product := new(domain.Product)
        if err := product.Bind(pdto); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.productRepository.CreateProduct(ctx, product); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.GenerateProductOutputDTO(product), nil</span>
}

func (s *productService) UpdateProduct(ctx context.Context, id uint, pdto *dto.ProductInputDTO) (*dto.ProductOutputDTO, error) <span class="cov0" title="0">{
        product := &amp;domain.Product{Base: domain.Base{ID: id}}
        if err := s.productRepository.GetProduct(ctx, product); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := product.Bind(pdto); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.productRepository.UpdateProduct(ctx, product); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.GenerateProductOutputDTO(product), nil</span>
}

func (s *productService) DeleteProducts(ctx context.Context, ids []uint) error <span class="cov0" title="0">{
        if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return s.productRepository.DeleteProducts(ctx, ids)</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package service

import (
        "context"

        "github.com/raulaguila/packhub"

        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/internal/pkg/dto"
        "github.com/raulaguila/go-api/pkg/pgfilter"
)

func NewProfileService(r domain.ProfileRepository) domain.ProfileService <span class="cov0" title="0">{
        return &amp;profileService{
                profileRepository: r,
        }
}</span>

type profileService struct {
        profileRepository domain.ProfileRepository
}

func (s *profileService) GenerateProfileOutputDTO(profile *domain.Profile) *dto.ProfileOutputDTO <span class="cov0" title="0">{
        return &amp;dto.ProfileOutputDTO{
                ID:          &amp;profile.ID,
                Name:        &amp;profile.Name,
                Permissions: &amp;profile.Permissions,
        }
}</span>

func (s *profileService) GetProfileByID(ctx context.Context, profileID uint) (*dto.ProfileOutputDTO, error) <span class="cov0" title="0">{
        profile := &amp;domain.Profile{Base: domain.Base{ID: profileID}}
        if err := s.profileRepository.GetProfile(ctx, profile); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.GenerateProfileOutputDTO(profile), nil</span>
}

func (s *profileService) GetProfiles(ctx context.Context, profileFilter *pgfilter.Filter) (*dto.ItemsOutputDTO[dto.ProfileOutputDTO], error) <span class="cov0" title="0">{
        profiles, err := s.profileRepository.GetProfiles(ctx, profileFilter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">count, err := s.profileRepository.CountProfiles(ctx, profileFilter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">outputProfiles := make([]dto.ProfileOutputDTO, len(*profiles))
        for i, profile := range *profiles </span><span class="cov0" title="0">{
                outputProfiles[i] = *s.GenerateProfileOutputDTO(&amp;profile)
        }</span>

        <span class="cov0" title="0">return &amp;dto.ItemsOutputDTO[dto.ProfileOutputDTO]{
                Items: outputProfiles,
                Pagination: dto.PaginationDTO{
                        CurrentPage: uint(packhub.Max(profileFilter.Page, 1)),
                        PageSize:    uint(packhub.Max(profileFilter.Limit, len(outputProfiles))),
                        TotalItems:  uint(count),
                        TotalPages:  uint(profileFilter.CalcPages(count)),
                },
        }, nil</span>
}

func (s *profileService) CreateProfile(ctx context.Context, pdto *dto.ProfileInputDTO) (*dto.ProfileOutputDTO, error) <span class="cov0" title="0">{
        profile := &amp;domain.Profile{Permissions: []string{}}
        if err := profile.Bind(pdto); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.profileRepository.CreateProfile(ctx, profile); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.GenerateProfileOutputDTO(profile), nil</span>
}

func (s *profileService) UpdateProfile(ctx context.Context, id uint, pdto *dto.ProfileInputDTO) (*dto.ProfileOutputDTO, error) <span class="cov0" title="0">{
        profile := &amp;domain.Profile{Base: domain.Base{ID: id}}
        if err := s.profileRepository.GetProfile(ctx, profile); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := profile.Bind(pdto); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.profileRepository.UpdateProfile(ctx, profile); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.GenerateProfileOutputDTO(profile), nil</span>
}

func (s *profileService) DeleteProfiles(ctx context.Context, ids []uint) error <span class="cov0" title="0">{
        if len(ids) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return s.profileRepository.DeleteProfiles(ctx, ids)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package service

import (
        "context"
        "fmt"

        "github.com/raulaguila/packhub"

        "github.com/raulaguila/go-api/internal/pkg/domain"
        "github.com/raulaguila/go-api/internal/pkg/dto"
        "github.com/raulaguila/go-api/pkg/utils"
)

func NewUserService(r domain.UserRepository) domain.UserService <span class="cov0" title="0">{
        return &amp;userService{
                userRepository: r,
        }
}</span>

type userService struct {
        userRepository domain.UserRepository
}

func (s *userService) GenerateUserOutputDTO(user *domain.User) *dto.UserOutputDTO <span class="cov0" title="0">{
        return &amp;dto.UserOutputDTO{
                ID:     &amp;user.ID,
                Name:   &amp;user.Name,
                Email:  &amp;user.Email,
                Status: &amp;user.Auth.Status,
                Profile: &amp;dto.ProfileOutputDTO{
                        ID:          &amp;user.Auth.Profile.ID,
                        Name:        &amp;user.Auth.Profile.Name,
                        Permissions: &amp;user.Auth.Profile.Permissions,
                },
        }
}</span>

func (s *userService) GetUserByID(ctx context.Context, userID uint) (*dto.UserOutputDTO, error) <span class="cov0" title="0">{
        user := &amp;domain.User{Base: domain.Base{ID: userID}}
        if err := s.userRepository.GetUser(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.GenerateUserOutputDTO(user), nil</span>
}

func (s *userService) GetUsers(ctx context.Context, userFilter *dto.UserFilter) (*dto.ItemsOutputDTO[dto.UserOutputDTO], error) <span class="cov0" title="0">{
        users, err := s.userRepository.GetUsers(ctx, userFilter)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("GetUsers Error: %v\n", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">count, err := s.userRepository.CountUsers(ctx, userFilter)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("CountUsers Error: %v\n", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">outputUsers := make([]dto.UserOutputDTO, 0)
        for _, user := range *users </span><span class="cov0" title="0">{
                outputUsers = append(outputUsers, *s.GenerateUserOutputDTO(&amp;user))
        }</span>

        <span class="cov0" title="0">return &amp;dto.ItemsOutputDTO[dto.UserOutputDTO]{
                Items: outputUsers,
                Pagination: dto.PaginationDTO{
                        CurrentPage: uint(packhub.Max(userFilter.Page, 1)),
                        PageSize:    uint(packhub.Max(userFilter.Limit, len(outputUsers))),
                        TotalItems:  uint(count),
                        TotalPages:  uint(userFilter.CalcPages(count)),
                },
        }, nil</span>
}

func (s *userService) CreateUser(ctx context.Context, data *dto.UserInputDTO) (*dto.UserOutputDTO, error) <span class="cov0" title="0">{
        user := &amp;domain.User{Auth: &amp;domain.Auth{}}
        if err := user.Bind(data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.userRepository.CreateUser(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">user = &amp;domain.User{Base: domain.Base{ID: user.ID}}
        if err := s.userRepository.GetUser(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.GenerateUserOutputDTO(user), nil</span>
}

func (s *userService) UpdateUser(ctx context.Context, userID uint, data *dto.UserInputDTO) (*dto.UserOutputDTO, error) <span class="cov0" title="0">{
        user := &amp;domain.User{Base: domain.Base{ID: userID}}
        if err := s.userRepository.GetUser(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := user.Bind(data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.userRepository.UpdateUser(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">user = &amp;domain.User{Base: domain.Base{ID: userID}}
        if err := s.userRepository.GetUser(ctx, user); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s.GenerateUserOutputDTO(user), nil</span>
}

func (s *userService) DeleteUsers(ctx context.Context, ids []uint) error <span class="cov0" title="0">{
        return s.userRepository.DeleteUsers(ctx, ids)
}</span>

func (s *userService) ResetUserPassword(ctx context.Context, mail string) error <span class="cov0" title="0">{
        user := &amp;domain.User{Email: mail}
        if err := s.userRepository.GetUser(ctx, user); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if user.Auth.Password == nil &amp;&amp; user.Auth.Token == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">user.ResetPassword()
        return s.userRepository.UpdateUser(ctx, user)</span>
}

func (s *userService) SetUserPassword(ctx context.Context, mail string, pass *dto.PasswordInputDTO) error <span class="cov0" title="0">{
        user := &amp;domain.User{Email: mail}
        if err := s.userRepository.GetUser(ctx, user); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if user.Auth.Password != nil </span><span class="cov0" title="0">{
                return utils.ErrUserHasPass
        }</span>

        <span class="cov0" title="0">if err := user.SetPassword(*pass.Password); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return s.userRepository.UpdateUser(ctx, user)</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package main

import (
        "bufio"
        "bytes"
        "encoding/base32"
        "fmt"
        "image/png"
        "os"
        "time"

        "github.com/pquerna/otp"
        "github.com/pquerna/otp/totp"
)

func display(key *otp.Key, data []byte) <span class="cov0" title="0">{
        fmt.Printf("Issuer:       %s\n", key.Issuer())
        fmt.Printf("Account Name: %s\n", key.AccountName())
        fmt.Printf("Secret:       %s\n", key.Secret())
        fmt.Println("Writing PNG to qr-code.png....")
        _ = os.WriteFile("qr-code.png", data, 0o644)
        fmt.Println("")
        fmt.Println("Please add your TOTP to your OTP Application now!")
        fmt.Println("")
}</span>

func promptForPasscode() string <span class="cov0" title="0">{
        reader := bufio.NewReader(os.Stdin)
        fmt.Print("Enter Passcode: ")
        text, _ := reader.ReadString('\n')
        return text
}</span>

// Demo function, not used in main
// Generates Passcode using a UTF-8 (not base32) secret and custom parameters
func GeneratePassCode(utf8string string) string <span class="cov0" title="0">{
        secret := base32.StdEncoding.EncodeToString([]byte(utf8string))
        passcode, err := totp.GenerateCodeCustom(secret, time.Now(), totp.ValidateOpts{
                Period:    30,
                Skew:      1,
                Digits:    otp.DigitsSix,
                Algorithm: otp.AlgorithmSHA512,
        })
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return passcode</span>
}

func main() <span class="cov0" title="0">{
        key, err := totp.Generate(totp.GenerateOpts{
                Issuer:      "Example.com",
                AccountName: "alice@example.com",
        })
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        // Convert TOTP key into a PNG
        <span class="cov0" title="0">var buf bytes.Buffer
        img, err := key.Image(200, 200)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">png.Encode(&amp;buf, img)

        // display the QR code to the user.
        display(key, buf.Bytes())

        // Now Validate that the user's successfully added the passcode.
        fmt.Println("Validating TOTP...")
        passcode := promptForPasscode()
        valid := totp.Validate(passcode, key.Secret())

        if valid </span><span class="cov0" title="0">{
                println("Valid passcode!")
                os.Exit(0)
        }</span> else<span class="cov0" title="0"> {
                println("Invalid passcode!")
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package pgerror

import (
        "errors"
        "fmt"

        "github.com/jackc/pgx/v5/pgconn"
)

var (
        ErrDuplicatedKey           = errors.New("duplicated key not allowed")
        ErrForeignKeyViolated      = errors.New("violates foreign key constraint")
        ErrUndefinedColumn         = errors.New("undefined column or parameter name")
        ErrDatabaseAlreadyExists   = errors.New("database already exists")
        ErrCheckConstraintViolated = errors.New("check constraint violated")
)

func HandlerError(err error) error <span class="cov8" title="1">{
        var pgError *pgconn.PgError
        if errors.As(err, &amp;pgError) </span><span class="cov8" title="1">{
                switch pgError.SQLState() </span>{
                case "23505":<span class="cov8" title="1">
                        return ErrDuplicatedKey</span>
                case "23503":<span class="cov8" title="1">
                        return ErrForeignKeyViolated</span>
                case "42703":<span class="cov8" title="1">
                        return ErrUndefinedColumn</span>
                case "42P04":<span class="cov8" title="1">
                        return ErrDatabaseAlreadyExists</span>
                case "23514":<span class="cov0" title="0">
                        return ErrCheckConstraintViolated</span>
                default:<span class="cov8" title="1">
                        fmt.Printf("PostgreSQL error not detected: %v\n", err)</span>
                }
        }

        <span class="cov8" title="1">return err</span>
}
</pre>
		
		<pre class="file" id="file38" style="display: none">package pgfilter

import (
        "fmt"
        "math"
        "os"
        "slices"
        "strings"
)

func New(sort, order string) *Filter <span class="cov8" title="1">{
        return &amp;Filter{
                Search: "",
                Page:   0,
                Limit:  0,
                Sort:   sort,
                Order:  order,
        }
}</span>

type Filter struct {
        Search string `query:"search" form:"search" example:"name"`
        Page   int    `query:"page" form:"page" minimum:"1" default:"1"`
        Limit  int    `query:"limit" form:"limit" minimum:"1" default:"10"`
        Sort   string `query:"sort" form:"sort" default:"updated_at" example:"updated_at"`
        Order  string `query:"order" form:"order" enums:"asc,desc" default:"desc"`
}

func (s *Filter) ApplySearchLike(columns ...string) (where string) <span class="cov8" title="1">{
        if len(columns) &gt; 0 &amp;&amp; s.Search != "" </span><span class="cov8" title="1">{
                whereFunc := func(column, value string) string </span><span class="cov8" title="1">{
                        return fmt.Sprintf("unaccent(LOWER(%s)) LIKE unaccent(LOWER('%%%s%%'))", column, value)
                }</span>

                <span class="cov8" title="1">for i, column := range columns </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                where += " or "
                        }</span>
                        <span class="cov8" title="1">where += whereFunc(column, s.Search)</span>
                }
        }

        <span class="cov8" title="1">return</span>
}

func (s *Filter) ApplyOrder(tbName *string) string <span class="cov8" title="1">{
        s.check()
        if tbName != nil &amp;&amp; !strings.Contains(s.Sort, ".") </span><span class="cov8" title="1">{
                return fmt.Sprintf("%v.%v %v", *tbName, s.Sort, s.Order)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%v %v", s.Sort, s.Order)</span>
}

func (s *Filter) ApplyPagination() (aux bool, offset, limit int) <span class="cov8" title="1">{
        if aux = s.Page &gt; 0 &amp;&amp; s.Limit &gt; 0; aux </span><span class="cov8" title="1">{
                offset = (s.Page - 1) * s.Limit
                limit = s.Limit
        }</span>

        <span class="cov8" title="1">return</span>
}

func (s *Filter) check() <span class="cov8" title="1">{
        if !slices.Contains([]string{"asc", "desc"}, strings.ToLower(s.Order)) </span><span class="cov8" title="1">{
                s.Order = os.Getenv("API_DEFAULT_ORDER")
        }</span>
        <span class="cov8" title="1">if s.Sort == "" </span><span class="cov8" title="1">{
                s.Sort = os.Getenv("API_DEFAULT_SORT")
        }</span>
}

func (s *Filter) CalcPages(count int64) int64 <span class="cov8" title="1">{
        if count == 0 </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">if s.Limit == 0 || s.Page == 0 </span><span class="cov8" title="1">{
                return 1
        }</span>

        <span class="cov8" title="1">return int64(math.Ceil(float64(count) / float64(s.Limit)))</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package utils

import (
        "errors"
        "strconv"
        "time"
)

var ErrIntConvert = errors.New("invalid string number")

func DurationFromString(str string, factor time.Duration) (time.Duration, error) <span class="cov8" title="1">{
        converted, err := strconv.Atoi(str)
        if err != nil </span><span class="cov8" title="1">{
                return time.Duration(0), ErrIntConvert
        }</span>

        <span class="cov8" title="1">return time.Duration(converted) * factor, nil</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">package utils

func PanicIfErr(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov8" title="1">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file41" style="display: none">package validator

import (
        "fmt"
)

type ValidateError struct {
        field string
        tag   string
        param string
        value any
}

func (m *ValidateError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf(`{"value":"%v","field":"%v","tag":"%v","param":"%v"}`, m.value, m.field, m.tag, m.param)
}</span>
</pre>
		
		<pre class="file" id="file42" style="display: none">package validator

import (
        "errors"

        "github.com/go-playground/validator/v10"
)

type validatorStruct struct {
        validator *validator.Validate
}

var StructValidator *validatorStruct

func init() <span class="cov8" title="1">{
        StructValidator = &amp;validatorStruct{
                validator: validator.New(),
        }
}</span>

func (v validatorStruct) Validate(data any) error <span class="cov8" title="1">{
        if result := v.validator.Struct(data); result != nil </span><span class="cov8" title="1">{
                var errs validator.ValidationErrors
                if errors.As(result, &amp;errs) </span><span class="cov8" title="1">{
                        for _, err := range errs </span><span class="cov8" title="1">{
                                return &amp;ValidateError{err.Field(), err.Tag(), err.Param(), err.Value()}
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
